[
  {
    "title": "A Taste of dplyr 1.0.0",
    "date": "2020-06-02T00:00:00.000Z",
    "description": "A quick summary of some exciting features coming in dplyr 1.0, e.g. `across()`, row-wise operations and context-dependent expressions",
    "metadata": {
      "readingTime": 15,
      "wordCount": 4014
    },
    "draft": false,
    "content": "<p>This post uses the penguins dataset [@10.1371/journal.pone.0090081]\nfor most demonstration purposes, modified by <a href=\"https://github.com/allisonhorst/penguins\">Allison\nHorst</a> (as an alternative to\n<code>iris</code>).</p>\n<i-code value=\"library(dplyr)\n#> \n#> Attaching package: &#x27;dplyr&#x27;\n#> The following objects are masked from &#x27;package:stats&#x27;:\n#> \n#>     filter, lag\n#> The following objects are masked from &#x27;package:base&#x27;:\n#> \n#>     intersect, setdiff, setequal, union\nlibrary(ggplot2)\n\npackageVersion(&#x22;dplyr&#x22;)\n#> [1] &#x27;1.1.2&#x27;\n\" lang=\"r\"></i-code>\n<i-code value=\"penguins <- palmerpenguins::penguins\npenguins\n#> # A tibble: 344 × 8\n#>    species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n#>    <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n#>  1 Adelie  Torgersen           39.1          18.7               181        3750\n#>  2 Adelie  Torgersen           39.5          17.4               186        3800\n#>  3 Adelie  Torgersen           40.3          18                 195        3250\n#>  4 Adelie  Torgersen           NA            NA                  NA          NA\n#>  5 Adelie  Torgersen           36.7          19.3               193        3450\n#>  6 Adelie  Torgersen           39.3          20.6               190        3650\n#>  7 Adelie  Torgersen           38.9          17.8               181        3625\n#>  8 Adelie  Torgersen           39.2          19.6               195        4675\n#>  9 Adelie  Torgersen           34.1          18.1               193        3475\n#> 10 Adelie  Torgersen           42            20.2               190        4250\n#> # ℹ 334 more rows\n#> # ℹ 2 more variables: sex <fct>, year <int>\n\" lang=\"r\"></i-code>\n<i-code value=\"penguins %>%\n  ggplot(aes(bill_length_mm, bill_depth_mm, color = species, shape = species)) +\n  geom_point()\n#> Warning: Removed 2 rows containing missing values or values outside the scale range\n#> (&#x60;geom_point()&#x60;).\n#> Warning in vp$just: partial match of &#x27;just&#x27; to &#x27;justification&#x27;\n\" lang=\"r\"></i-code>\n<img src=\"/static/unnamed-chunk-4-1-3e078baa.png\" alt=\"\">\n<h2>Working within columns</h2>\n<p>The new <code>across()</code> function supersedes functionalities of <code>_at</code>, <code>_if</code>,\n<code>_all</code> variants. The first argument, <code>.cols</code>, selects the columns you\nwant to operate on. It uses tidy selection (like <code>select()</code>) so you can\npick variables by position, name, and type. The second argument, <code>.fns</code>,\nis a function or list of functions to apply to each column. This can\nalso be a purrr style formula</p>\n<i-code value=\"penguins_grouped <- penguins %>% group_by(species)\n\npenguins_grouped %>%\n  summarize(across(starts_with(&#x22;bill&#x22;), mean, na.rm = TRUE),\n    n = n()\n  )\n#> Warning: There was 1 warning in &#x60;summarize()&#x60;.\n#> ℹ In argument: &#x60;across(starts_with(&#x22;bill&#x22;), mean, na.rm = TRUE)&#x60;.\n#> ℹ In group 1: &#x60;species = Adelie&#x60;.\n#> Caused by warning:\n#> ! The &#x60;...&#x60; argument of &#x60;across()&#x60; is deprecated as of dplyr 1.1.0.\n#> Supply arguments directly to &#x60;.fns&#x60; through an anonymous function instead.\n#> \n#>   # Previously\n#>   across(a:b, mean, na.rm = TRUE)\n#> \n#>   # Now\n#>   across(a:b, \\(x) mean(x, na.rm = TRUE))\n#> # A tibble: 3 × 4\n#>   species   bill_length_mm bill_depth_mm     n\n#>   <fct>              <dbl>         <dbl> <int>\n#> 1 Adelie              38.8          18.3   152\n#> 2 Chinstrap           48.8          18.4    68\n#> 3 Gentoo              47.5          15.0   124\n\" lang=\"r\"></i-code>\n<p>For conditional selection (previous <code>_if</code> variants), predicate function\nshould be wrapped in <code>where</code>.</p>\n<i-code value=\"# double all numeric columns\npenguins %>%\n  mutate(across(where(is.numeric), ~ .x * 2))\n#> # A tibble: 344 × 8\n#>    species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n#>    <fct>   <fct>              <dbl>         <dbl>             <dbl>       <dbl>\n#>  1 Adelie  Torgersen           78.2          37.4               362        7500\n#>  2 Adelie  Torgersen           79            34.8               372        7600\n#>  3 Adelie  Torgersen           80.6          36                 390        6500\n#>  4 Adelie  Torgersen           NA            NA                  NA          NA\n#>  5 Adelie  Torgersen           73.4          38.6               386        6900\n#>  6 Adelie  Torgersen           78.6          41.2               380        7300\n#>  7 Adelie  Torgersen           77.8          35.6               362        7250\n#>  8 Adelie  Torgersen           78.4          39.2               390        9350\n#>  9 Adelie  Torgersen           68.2          36.2               386        6950\n#> 10 Adelie  Torgersen           84            40.4               380        8500\n#> # ℹ 334 more rows\n#> # ℹ 2 more variables: sex <fct>, year <dbl>\n\n# count unique values of all character columns\npenguins %>%\n  summarize(across(where(is.character), ~ length(unique(.x))))\n#> # A tibble: 1 × 0\n\" lang=\"r\"></i-code>\n<p>Apply multiple functions using list and use the <code>.names</code> argument to\ncontrol column names.</p>\n<i-code value=\"penguins_grouped %>%\n  summarize(across(matches(&#x22;mm&#x22;),\n    list(\n      min = ~ min(.x, na.rm = TRUE),\n      max = ~ max(.x, na.rm = TRUE)\n    ),\n    .names = &#x22;{fn}_{col}&#x22;\n  ))\n#> # A tibble: 3 × 7\n#>   species   min_bill_length_mm max_bill_length_mm min_bill_depth_mm\n#>   <fct>                  <dbl>              <dbl>             <dbl>\n#> 1 Adelie                  32.1               46                15.5\n#> 2 Chinstrap               40.9               58                16.4\n#> 3 Gentoo                  40.9               59.6              13.1\n#> # ℹ 3 more variables: max_bill_depth_mm <dbl>, min_flipper_length_mm <int>,\n#> #   max_flipper_length_mm <int>\n\" lang=\"r\"></i-code>\n<h2>Working within rows</h2>\n<p>Row-wise operations require a special type of grouping where each group\nconsists of a single row. You create this with <code>rowwise()</code>.</p>\n<i-code value=\"df <- tibble(\n  student_id = 1:4,\n  test1 = 10:13,\n  test2 = 20:23,\n  test3 = 30:33,\n  test4 = 40:43\n)\ndf %>% rowwise()\n#> # A tibble: 4 × 5\n#> # Rowwise: \n#>   student_id test1 test2 test3 test4\n#>        <int> <int> <int> <int> <int>\n#> 1          1    10    20    30    40\n#> 2          2    11    21    31    41\n#> 3          3    12    22    32    42\n#> 4          4    13    23    33    43\n\" lang=\"r\"></i-code>\n<p><code>rowwise</code> doesn’t need any additional arguments unless you have\nvariables that identify the rows, like <code>student_id</code> here. This can be\nhelpful when you want to keep a row identifier.</p>\n<p>Like <code>group_by</code>, <code>rowwise</code> doesn’t really do anything itself; it just\nchanges how the other verbs work.</p>\n<i-code value=\"df %>% mutate(avg = mean(c(test1, test2, test3, test4)))\n#> # A tibble: 4 × 6\n#>   student_id test1 test2 test3 test4   avg\n#>        <int> <int> <int> <int> <int> <dbl>\n#> 1          1    10    20    30    40  26.5\n#> 2          2    11    21    31    41  26.5\n#> 3          3    12    22    32    42  26.5\n#> 4          4    13    23    33    43  26.5\n\ndf %>%\n  rowwise() %>%\n  mutate(avg = mean(c(test1, test2, test3, test4)))\n#> # A tibble: 4 × 6\n#> # Rowwise: \n#>   student_id test1 test2 test3 test4   avg\n#>        <int> <int> <int> <int> <int> <dbl>\n#> 1          1    10    20    30    40    25\n#> 2          2    11    21    31    41    26\n#> 3          3    12    22    32    42    27\n#> 4          4    13    23    33    43    28\n\" lang=\"r\"></i-code>\n<p>In its essence, <code>rowwise</code> vectorize / parallelize a function to acheive\nrowwisee computation. And in this case, the <code>mean()</code> function is\nvectorized. If there are alternative ways of computing row-wise\nsummaries that take advantage of built-in vectorisation then we do not\nneed <code>rowwise</code> at all.</p>\n<i-code value=\"df %>% mutate(s = test1 + test2 + test3)\n#> # A tibble: 4 × 6\n#>   student_id test1 test2 test3 test4     s\n#>        <int> <int> <int> <int> <int> <int>\n#> 1          1    10    20    30    40    60\n#> 2          2    11    21    31    41    63\n#> 3          3    12    22    32    42    66\n#> 4          4    13    23    33    43    69\n\ndf %>%\n  rowwise() %>%\n  mutate(s = test1 + test2 + test3)\n#> # A tibble: 4 × 6\n#> # Rowwise: \n#>   student_id test1 test2 test3 test4     s\n#>        <int> <int> <int> <int> <int> <int>\n#> 1          1    10    20    30    40    60\n#> 2          2    11    21    31    41    63\n#> 3          3    12    22    32    42    66\n#> 4          4    13    23    33    43    69\n\" lang=\"r\"></i-code>\n<p>Another family of summary functions have “parallel” extensions where you\ncan provide multiple variables in the arguments:</p>\n<i-code value=\"df %>%\n  mutate(\n    min = pmin(test1, test2, test3, test4),\n    max = pmax(test1, test2, test3, test4),\n    string = paste(test1, test2, test3, test4, sep = &#x22;-&#x22;)\n  )\n#> # A tibble: 4 × 8\n#>   student_id test1 test2 test3 test4   min   max string     \n#>        <int> <int> <int> <int> <int> <int> <int> <chr>      \n#> 1          1    10    20    30    40    10    40 10-20-30-40\n#> 2          2    11    21    31    41    11    41 11-21-31-41\n#> 3          3    12    22    32    42    12    42 12-22-32-42\n#> 4          4    13    23    33    43    13    43 13-23-33-43\n\" lang=\"r\"></i-code>\n<p>Where these functions exist, they’ll usually be faster than <code>rowwise</code>.\nThe advantage of <code>rowwise</code> is that it works with any function, not just\nthose that are already vectorised.</p>\n<p>However, an advantage of <code>rowwise</code> even there is other ways is that it’s\npaired with <code>c_across()</code>, which works like <code>c()</code> but uses the same\ntidyselect syntax as <code>across()</code>. That makes it easy to operate on\nmultiple variables:</p>\n<i-code value=\"df %>%\n  rowwise() %>%\n  mutate(\n    min = min(c_across(starts_with(&#x22;test&#x22;))),\n    max = max(c_across(starts_with(&#x22;test&#x22;)))\n  )\n#> # A tibble: 4 × 7\n#> # Rowwise: \n#>   student_id test1 test2 test3 test4   min   max\n#>        <int> <int> <int> <int> <int> <int> <int>\n#> 1          1    10    20    30    40    10    40\n#> 2          2    11    21    31    41    11    41\n#> 3          3    12    22    32    42    12    42\n#> 4          4    13    23    33    43    13    43\n\" lang=\"r\"></i-code>\n<p>Plus, a rowwise df will naturally contain exactly the same rows after\n<code>summarize()</code>, the same as <code>mutate</code></p>\n<i-code value=\"df %>%\n  rowwise() %>%\n  summarize(across(starts_with(&#x22;test&#x22;), ~.x, .names = &#x22;{col}_same&#x22;))\n#> # A tibble: 4 × 4\n#>   test1_same test2_same test3_same test4_same\n#>        <int>      <int>      <int>      <int>\n#> 1         10         20         30         40\n#> 2         11         21         31         41\n#> 3         12         22         32         42\n#> 4         13         23         33         43\n\" lang=\"r\"></i-code>\n<h3>List-columns</h3>\n<p>Because lists can contain anything, you can use list-columns to keep\nrelated objects together, regardless of what type of thing they are.\nList-columns give you a convenient storage mechanism and <code>rowwise</code> gives\nyou a convenient computation mechanism.</p>\n<i-code value=\"df <- tibble(\n  x = list(1, 2:3, 4:6),\n  y = list(TRUE, 1, &#x22;a&#x22;),\n  z = list(sum, mean, sd)\n)\ndf\n#> # A tibble: 3 × 3\n#>   x         y         z     \n#>   <list>    <list>    <list>\n#> 1 <dbl [1]> <lgl [1]> <fn>  \n#> 2 <int [2]> <dbl [1]> <fn>  \n#> 3 <int [3]> <chr [1]> <fn>\n\" lang=\"r\"></i-code>\n<i-code value=\"df %>%\n  rowwise() %>%\n  summarize(\n    x_length = length(x),\n    y_type = typeof(y),\n    z_call = z(1:5)\n  )\n#> # A tibble: 3 × 3\n#>   x_length y_type    z_call\n#>      <int> <chr>      <dbl>\n#> 1        1 logical    15   \n#> 2        2 double      3   \n#> 3        3 character   1.58\n\" lang=\"r\"></i-code>\n<h3>Simulaiton</h3>\n<p>The basic idea of using <code>rowwise</code> to perform simulation is to store all\nyour simulation paramters in a data frame, similar to <code>purrr::pmap</code>.</p>\n<i-code value=\"df <- tribble(\n  ~id, ~n, ~min, ~max,\n  1, 3, 0, 1,\n  2, 2, 10, 100,\n  3, 2, 100, 1000,\n)\n\" lang=\"r\"></i-code>\n<p>Then you can either generate a list-column containing the simulated\nvalues with <code>mutate</code>:</p>\n<i-code value=\"df %>%\n  rowwise() %>%\n  mutate(sim = list(runif(n, min, max)))\n#> # A tibble: 3 × 5\n#> # Rowwise: \n#>      id     n   min   max sim      \n#>   <dbl> <dbl> <dbl> <dbl> <list>   \n#> 1     1     3     0     1 <dbl [3]>\n#> 2     2     2    10   100 <dbl [2]>\n#> 3     3     2   100  1000 <dbl [2]>\n\" lang=\"r\"></i-code>\n<p>Or taking advantage of <code>summarize</code>’s new features to return multiple\nrows per group</p>\n<i-code value=\"df %>%\n  rowwise(everything()) %>%\n  summarize(sim = runif(n, min, max))\n#> Warning: Returning more (or less) than 1 row per &#x60;summarise()&#x60; group was deprecated in\n#> dplyr 1.1.0.\n#> ℹ Please use &#x60;reframe()&#x60; instead.\n#> ℹ When switching from &#x60;summarise()&#x60; to &#x60;reframe()&#x60;, remember that &#x60;reframe()&#x60;\n#>   always returns an ungrouped data frame and adjust accordingly.\n#> &#x60;summarise()&#x60; has grouped output by &#x27;id&#x27;, &#x27;n&#x27;, &#x27;min&#x27;, &#x27;max&#x27;. You can override\n#> using the &#x60;.groups&#x60; argument.\n#> # A tibble: 7 × 5\n#> # Groups:   id, n, min, max [3]\n#>      id     n   min   max     sim\n#>   <dbl> <dbl> <dbl> <dbl>   <dbl>\n#> 1     1     3     0     1   0.702\n#> 2     1     3     0     1   0.801\n#> 3     1     3     0     1   0.457\n#> 4     2     2    10   100  44.7  \n#> 5     2     2    10   100  18.3  \n#> 6     3     2   100  1000 930.   \n#> 7     3     2   100  1000 723.\n\" lang=\"r\"></i-code>\n<p>The previous approach</p>\n<i-code value=\"df %>%\n  mutate(sim = purrr::pmap(., ~ runif(..2, ..3, ..4)))\n#> # A tibble: 3 × 5\n#>      id     n   min   max sim      \n#>   <dbl> <dbl> <dbl> <dbl> <list>   \n#> 1     1     3     0     1 <dbl [3]>\n#> 2     2     2    10   100 <dbl [2]>\n#> 3     3     2   100  1000 <dbl [2]>\n\" lang=\"r\"></i-code>\n<h2>Group-wise models</h2>\n<p>The new <code>nest_by()</code> function works similarly to <code>group_nest()</code></p>\n<i-code value=\"by_species <- penguins %>% nest_by(species)\nby_species\n#> # A tibble: 3 × 2\n#> # Rowwise:  species\n#>   species                 data\n#>   <fct>     <list<tibble[,7]>>\n#> 1 Adelie             [152 × 7]\n#> 2 Chinstrap           [68 × 7]\n#> 3 Gentoo             [124 × 7]\n\" lang=\"r\"></i-code>\n<p>Now we can use <code>mutate</code> to fit a model to each data frame:</p>\n<i-code value=\"by_species <- by_species %>%\n  rowwise(species) %>%\n  mutate(model = list(lm(bill_length_mm ~ bill_depth_mm, data = data)))\n\nby_species\n#> # A tibble: 3 × 3\n#> # Rowwise:  species\n#>   species                 data model \n#>   <fct>     <list<tibble[,7]>> <list>\n#> 1 Adelie             [152 × 7] <lm>  \n#> 2 Chinstrap           [68 × 7] <lm>  \n#> 3 Gentoo             [124 × 7] <lm>\n\" lang=\"r\"></i-code>\n<p>And then extract model summaries or coefficients with <code>summarize()</code> and\n<code>broom</code> functions (note that <code>by_species</code> is still a rowwise data\nframe):</p>\n<i-code value=\"by_species %>%\n  summarize(broom::glance(model))\n#> &#x60;summarise()&#x60; has grouped output by &#x27;species&#x27;. You can override using the\n#> &#x60;.groups&#x60; argument.\n#> # A tibble: 3 × 13\n#> # Groups:   species [3]\n#>   species   r.squared adj.r.squared sigma statistic  p.value    df logLik   AIC\n#>   <fct>         <dbl>         <dbl> <dbl>     <dbl>    <dbl> <dbl>  <dbl> <dbl>\n#> 1 Adelie        0.153         0.148  2.46      27.0 6.67e- 7     1  -349.  704.\n#> 2 Chinstrap     0.427         0.418  2.55      49.2 1.53e- 9     1  -159.  324.\n#> 3 Gentoo        0.414         0.409  2.37      85.5 1.02e-15     1  -280.  565.\n#> # ℹ 4 more variables: BIC <dbl>, deviance <dbl>, df.residual <int>, nobs <int>\n\nby_species %>%\n  summarize(broom::tidy(model))\n#> Warning: Returning more (or less) than 1 row per &#x60;summarise()&#x60; group was deprecated in\n#> dplyr 1.1.0.\n#> ℹ Please use &#x60;reframe()&#x60; instead.\n#> ℹ When switching from &#x60;summarise()&#x60; to &#x60;reframe()&#x60;, remember that &#x60;reframe()&#x60;\n#>   always returns an ungrouped data frame and adjust accordingly.\n#> &#x60;summarise()&#x60; has grouped output by &#x27;species&#x27;. You can override using the\n#> &#x60;.groups&#x60; argument.\n#> # A tibble: 6 × 6\n#> # Groups:   species [3]\n#>   species   term          estimate std.error statistic  p.value\n#>   <fct>     <chr>            <dbl>     <dbl>     <dbl>    <dbl>\n#> 1 Adelie    (Intercept)     23.1       3.03       7.60 3.01e-12\n#> 2 Adelie    bill_depth_mm    0.857     0.165      5.19 6.67e- 7\n#> 3 Chinstrap (Intercept)     13.4       5.06       2.66 9.92e- 3\n#> 4 Chinstrap bill_depth_mm    1.92      0.274      7.01 1.53e- 9\n#> 5 Gentoo    (Intercept)     17.2       3.28       5.25 6.60e- 7\n#> 6 Gentoo    bill_depth_mm    2.02      0.219      9.24 1.02e-15\n\" lang=\"r\"></i-code>\n<p>An alternative approach</p>\n<i-code value=\"penguins %>%\n  group_by(species) %>%\n  group_modify(~ broom::tidy(lm(bill_length_mm ~ bill_depth_mm, data = .x)))\n#> # A tibble: 6 × 6\n#> # Groups:   species [3]\n#>   species   term          estimate std.error statistic  p.value\n#>   <fct>     <chr>            <dbl>     <dbl>     <dbl>    <dbl>\n#> 1 Adelie    (Intercept)     23.1       3.03       7.60 3.01e-12\n#> 2 Adelie    bill_depth_mm    0.857     0.165      5.19 6.67e- 7\n#> 3 Chinstrap (Intercept)     13.4       5.06       2.66 9.92e- 3\n#> 4 Chinstrap bill_depth_mm    1.92      0.274      7.01 1.53e- 9\n#> 5 Gentoo    (Intercept)     17.2       3.28       5.25 6.60e- 7\n#> 6 Gentoo    bill_depth_mm    2.02      0.219      9.24 1.02e-15\n\" lang=\"r\"></i-code>\n<h2>New <code>summarize</code> features</h2>\n<h3>Multiple rows and columns</h3>\n<p>Two big changes make <code>summarize()</code> much more flexible. A single summary\nexpression can now return:</p>\n<ul>\n<li>\n<p>A vector of any length, creating multiple rows. (so we can use summary\nthat returns multiple values without <code>list</code>)</p>\n</li>\n<li>\n<p>A data frame, creating multiple columns.</p>\n</li>\n</ul>\n<i-code value=\"penguins_grouped %>%\n  summarize(\n    bill_length_dist = quantile(bill_length_mm,\n      c(0.25, 0.5, 0.75),\n      na.rm = TRUE\n    ),\n    q = c(0.25, 0.5, 0.75)\n  )\n#> Warning: Returning more (or less) than 1 row per &#x60;summarise()&#x60; group was deprecated in\n#> dplyr 1.1.0.\n#> ℹ Please use &#x60;reframe()&#x60; instead.\n#> ℹ When switching from &#x60;summarise()&#x60; to &#x60;reframe()&#x60;, remember that &#x60;reframe()&#x60;\n#>   always returns an ungrouped data frame and adjust accordingly.\n#> &#x60;summarise()&#x60; has grouped output by &#x27;species&#x27;. You can override using the\n#> &#x60;.groups&#x60; argument.\n#> # A tibble: 9 × 3\n#> # Groups:   species [3]\n#>   species   bill_length_dist     q\n#>   <fct>                <dbl> <dbl>\n#> 1 Adelie                36.8  0.25\n#> 2 Adelie                38.8  0.5 \n#> 3 Adelie                40.8  0.75\n#> 4 Chinstrap             46.3  0.25\n#> 5 Chinstrap             49.6  0.5 \n#> 6 Chinstrap             51.1  0.75\n#> 7 Gentoo                45.3  0.25\n#> 8 Gentoo                47.3  0.5 \n#> 9 Gentoo                49.6  0.75\n\" lang=\"r\"></i-code>\n<p>Or return multiple columns from a single summary expression:</p>\n<i-code value=\"penguins_grouped %>%\n  summarize(tibble(\n    min = min(bill_depth_mm, na.rm = TRUE),\n    max = max(bill_depth_mm, na.rm = TRUE)\n  ))\n#> # A tibble: 3 × 3\n#>   species     min   max\n#>   <fct>     <dbl> <dbl>\n#> 1 Adelie     15.5  21.5\n#> 2 Chinstrap  16.4  20.8\n#> 3 Gentoo     13.1  17.3\n\" lang=\"r\"></i-code>\n<p>At the first glance this may seem not so different with supplying\nmultiple name-value pairs. But this can be useful inside functions. For\nexample, in the previous <code>quantile</code> code it would be nice to be able to\nreduce the duplication so that we don’t have to type the quantile values\ntwice. We can now write a simple function because summary expressions\ncan now be data frames or tibbles:</p>\n<i-code value=\"quibble <- function(x, q = c(0.25, 0.5, 0.75), na.rm = TRUE) {\n  tibble(x = quantile(x, q, na.rm = na.rm), q = q)\n}\n\npenguins_grouped %>%\n  summarize(quibble(bill_depth_mm))\n#> Warning: Returning more (or less) than 1 row per &#x60;summarise()&#x60; group was deprecated in\n#> dplyr 1.1.0.\n#> ℹ Please use &#x60;reframe()&#x60; instead.\n#> ℹ When switching from &#x60;summarise()&#x60; to &#x60;reframe()&#x60;, remember that &#x60;reframe()&#x60;\n#>   always returns an ungrouped data frame and adjust accordingly.\n#> &#x60;summarise()&#x60; has grouped output by &#x27;species&#x27;. You can override using the\n#> &#x60;.groups&#x60; argument.\n#> # A tibble: 9 × 3\n#> # Groups:   species [3]\n#>   species       x     q\n#>   <fct>     <dbl> <dbl>\n#> 1 Adelie     17.5  0.25\n#> 2 Adelie     18.4  0.5 \n#> 3 Adelie     19    0.75\n#> 4 Chinstrap  17.5  0.25\n#> 5 Chinstrap  18.4  0.5 \n#> 6 Chinstrap  19.4  0.75\n#> 7 Gentoo     14.2  0.25\n#> 8 Gentoo     15    0.5 \n#> 9 Gentoo     15.7  0.75\n\" lang=\"r\"></i-code>\n<p>When combining glue syntax and tidy evaluation, it is easy to\ndynamically name the column names.</p>\n<i-code value=\"quibble <- function(x, q = c(0.25, 0.5, 0.75), na.rm = TRUE) {\n  tibble(\n    &#x22;{{ x }}_quantile&#x22; := quantile(x, q, na.rm = na.rm),\n    &#x22;{{ x }}_q&#x22; := q\n  )\n}\n\npenguins_grouped %>%\n  summarize(quibble(flipper_length_mm))\n#> Warning: Returning more (or less) than 1 row per &#x60;summarise()&#x60; group was deprecated in\n#> dplyr 1.1.0.\n#> ℹ Please use &#x60;reframe()&#x60; instead.\n#> ℹ When switching from &#x60;summarise()&#x60; to &#x60;reframe()&#x60;, remember that &#x60;reframe()&#x60;\n#>   always returns an ungrouped data frame and adjust accordingly.\n#> &#x60;summarise()&#x60; has grouped output by &#x27;species&#x27;. You can override using the\n#> &#x60;.groups&#x60; argument.\n#> # A tibble: 9 × 3\n#> # Groups:   species [3]\n#>   species   flipper_length_mm_quantile flipper_length_mm_q\n#>   <fct>                          <dbl>               <dbl>\n#> 1 Adelie                           186                0.25\n#> 2 Adelie                           190                0.5 \n#> 3 Adelie                           195                0.75\n#> 4 Chinstrap                        191                0.25\n#> 5 Chinstrap                        196                0.5 \n#> 6 Chinstrap                        201                0.75\n#> 7 Gentoo                           212                0.25\n#> 8 Gentoo                           216                0.5 \n#> 9 Gentoo                           221                0.75\n\" lang=\"r\"></i-code>\n<p>As an aside, if we name the tibble expression in <code>summarize()</code> that part\nwill be packed in the result, which can be solved by <code>tidyr::unpack</code>.\nThat’s because when we leave the name off, the data frame result is\nautomatically unpacked.</p>\n<i-code value=\"penguins_grouped %>%\n  summarize(df = quibble(flipper_length_mm))\n#> Warning: Returning more (or less) than 1 row per &#x60;summarise()&#x60; group was deprecated in\n#> dplyr 1.1.0.\n#> ℹ Please use &#x60;reframe()&#x60; instead.\n#> ℹ When switching from &#x60;summarise()&#x60; to &#x60;reframe()&#x60;, remember that &#x60;reframe()&#x60;\n#>   always returns an ungrouped data frame and adjust accordingly.\n#> &#x60;summarise()&#x60; has grouped output by &#x27;species&#x27;. You can override using the\n#> &#x60;.groups&#x60; argument.\n#> # A tibble: 9 × 2\n#> # Groups:   species [3]\n#>   species   df$flipper_length_mm_quantile $flipper_length_mm_q\n#>   <fct>                             <dbl>                <dbl>\n#> 1 Adelie                              186                 0.25\n#> 2 Adelie                              190                 0.5 \n#> 3 Adelie                              195                 0.75\n#> 4 Chinstrap                           191                 0.25\n#> 5 Chinstrap                           196                 0.5 \n#> 6 Chinstrap                           201                 0.75\n#> 7 Gentoo                              212                 0.25\n#> 8 Gentoo                              216                 0.5 \n#> 9 Gentoo                              221                 0.75\n\" lang=\"r\"></i-code>\n<h3>non-summary context</h3>\n<p>In combination with rowwise operations, <code>summarize()</code> is now\nsufficiently powerful to replace many workflows that previously required\na <code>map()</code> function.</p>\n<p>For example, to read all the all the .csv files in the current\ndirectory, you could write:</p>\n<i-code value=\"tibble(path = dir(pattern = &#x22;\\\\.csv$&#x22;)) %>%\n  rowwise(path) %>%\n  summarize(read_csv(path))\n\" lang=\"r\"></i-code>\n<h2>Move columns around within data frames</h2>\n<p>New verb <code>relocate</code> is provided to change column positions with the same\nsyntax as <code>select</code>. The default behavior is to move selected columns to\nthe left-hand side</p>\n<i-code value=\"penguins %>% relocate(island)\n#> # A tibble: 344 × 8\n#>    island    species bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n#>    <fct>     <fct>            <dbl>         <dbl>             <int>       <int>\n#>  1 Torgersen Adelie            39.1          18.7               181        3750\n#>  2 Torgersen Adelie            39.5          17.4               186        3800\n#>  3 Torgersen Adelie            40.3          18                 195        3250\n#>  4 Torgersen Adelie            NA            NA                  NA          NA\n#>  5 Torgersen Adelie            36.7          19.3               193        3450\n#>  6 Torgersen Adelie            39.3          20.6               190        3650\n#>  7 Torgersen Adelie            38.9          17.8               181        3625\n#>  8 Torgersen Adelie            39.2          19.6               195        4675\n#>  9 Torgersen Adelie            34.1          18.1               193        3475\n#> 10 Torgersen Adelie            42            20.2               190        4250\n#> # ℹ 334 more rows\n#> # ℹ 2 more variables: sex <fct>, year <int>\n\npenguins %>% relocate(starts_with(&#x22;bill&#x22;))\n#> # A tibble: 344 × 8\n#>    bill_length_mm bill_depth_mm species island    flipper_length_mm body_mass_g\n#>             <dbl>         <dbl> <fct>   <fct>                 <int>       <int>\n#>  1           39.1          18.7 Adelie  Torgersen               181        3750\n#>  2           39.5          17.4 Adelie  Torgersen               186        3800\n#>  3           40.3          18   Adelie  Torgersen               195        3250\n#>  4           NA            NA   Adelie  Torgersen                NA          NA\n#>  5           36.7          19.3 Adelie  Torgersen               193        3450\n#>  6           39.3          20.6 Adelie  Torgersen               190        3650\n#>  7           38.9          17.8 Adelie  Torgersen               181        3625\n#>  8           39.2          19.6 Adelie  Torgersen               195        4675\n#>  9           34.1          18.1 Adelie  Torgersen               193        3475\n#> 10           42            20.2 Adelie  Torgersen               190        4250\n#> # ℹ 334 more rows\n#> # ℹ 2 more variables: sex <fct>, year <int>\n\npenguins %>% relocate(sex, body_mass_g, .after = species)\n#> # A tibble: 344 × 8\n#>    species sex    body_mass_g island    bill_length_mm bill_depth_mm\n#>    <fct>   <fct>        <int> <fct>              <dbl>         <dbl>\n#>  1 Adelie  male          3750 Torgersen           39.1          18.7\n#>  2 Adelie  female        3800 Torgersen           39.5          17.4\n#>  3 Adelie  female        3250 Torgersen           40.3          18  \n#>  4 Adelie  <NA>            NA Torgersen           NA            NA  \n#>  5 Adelie  female        3450 Torgersen           36.7          19.3\n#>  6 Adelie  male          3650 Torgersen           39.3          20.6\n#>  7 Adelie  female        3625 Torgersen           38.9          17.8\n#>  8 Adelie  male          4675 Torgersen           39.2          19.6\n#>  9 Adelie  <NA>          3475 Torgersen           34.1          18.1\n#> 10 Adelie  <NA>          4250 Torgersen           42            20.2\n#> # ℹ 334 more rows\n#> # ℹ 2 more variables: flipper_length_mm <int>, year <int>\n\" lang=\"r\"></i-code>\n<p>Similarly, <code>mutate</code> gains new arguments <code>.after</code> and <code>.before</code> to\ncontrol where new columns should appear.</p>\n<i-code value=\"penguins %>%\n  mutate(mass_double = body_mass_g * 2, .before = 1)\n#> # A tibble: 344 × 9\n#>    mass_double species island    bill_length_mm bill_depth_mm flipper_length_mm\n#>          <dbl> <fct>   <fct>              <dbl>         <dbl>             <int>\n#>  1        7500 Adelie  Torgersen           39.1          18.7               181\n#>  2        7600 Adelie  Torgersen           39.5          17.4               186\n#>  3        6500 Adelie  Torgersen           40.3          18                 195\n#>  4          NA Adelie  Torgersen           NA            NA                  NA\n#>  5        6900 Adelie  Torgersen           36.7          19.3               193\n#>  6        7300 Adelie  Torgersen           39.3          20.6               190\n#>  7        7250 Adelie  Torgersen           38.9          17.8               181\n#>  8        9350 Adelie  Torgersen           39.2          19.6               195\n#>  9        6950 Adelie  Torgersen           34.1          18.1               193\n#> 10        8500 Adelie  Torgersen           42            20.2               190\n#> # ℹ 334 more rows\n#> # ℹ 3 more variables: body_mass_g <int>, sex <fct>, year <int>\n\" lang=\"r\"></i-code>\n<h2>Row mutation</h2>\n<p>dplyr has a new experimental family of row mutation functions inspired\nby SQL’s <code>UPDATE</code>, <code>INSERT</code>, <code>UPSERT</code>, and <code>DELETE</code>. Like the join\nfunctions, they all work with a pair of data frames:</p>\n<ul>\n<li>\n<p><code>rows_update(x, y)</code> updates existing rows in x with values in y.</p>\n</li>\n<li>\n<p><code>rows_patch(x, y)</code> works like rows_update() but only changes <code>NA</code>\nvalues.</p>\n</li>\n<li>\n<p><code>rows_insert(x, y)</code> adds new rows to x from y.</p>\n</li>\n<li>\n<p><code>rows_upsert(x, y)</code> updates existing rows in x and adds new rows from\ny.</p>\n</li>\n<li>\n<p><code>rows_delete(x, y)</code> deletes rows in x that match rows in y.</p>\n</li>\n</ul>\n<p>The <code>rows_</code> functions match x and y using <strong>keys</strong>. All of them check\nthat the keys of x and y are valid (i.e. unique) before doing anything.</p>\n<i-code value=\"df <- tibble(a = 1:3, b = letters[c(1:2, NA)], c = 0.5 + 0:2)\ndf\n#> # A tibble: 3 × 3\n#>       a b         c\n#>   <int> <chr> <dbl>\n#> 1     1 a       0.5\n#> 2     2 b       1.5\n#> 3     3 <NA>    2.5\n\" lang=\"r\"></i-code>\n<p>We can use <code>rows_insert()</code> to add new rows:</p>\n<i-code value=\"new <- tibble(a = c(4, 5), b = c(&#x22;d&#x22;, &#x22;e&#x22;), c = c(3.5, 4.5))\n\nrows_insert(df, new)\n#> Matching, by = &#x22;a&#x22;\n#> # A tibble: 5 × 3\n#>       a b         c\n#>   <int> <chr> <dbl>\n#> 1     1 a       0.5\n#> 2     2 b       1.5\n#> 3     3 <NA>    2.5\n#> 4     4 d       3.5\n#> 5     5 e       4.5\n\" lang=\"r\"></i-code>\n<p>Note that <code>rows_insert()</code> will fail if we attempt to insert a row that\nalready exists:</p>\n<i-code value=\"df %>% rows_insert(tibble(a = 3, b = &#x22;c&#x22;))\n#> Matching, by = &#x22;a&#x22;\n#> Error in &#x60;rows_insert()&#x60;:\n#> ! &#x60;y&#x60; can&#x27;t contain keys that already exist in &#x60;x&#x60;.\n#> ℹ The following rows in &#x60;y&#x60; have keys that already exist in &#x60;x&#x60;: &#x60;c(1)&#x60;.\n#> ℹ Use &#x60;conflict = &#x22;ignore&#x22;&#x60; if you want to ignore these &#x60;y&#x60; rows.\n\ndf %>% rows_insert(tibble(a = 3, b = &#x22;c&#x22;), by = c(&#x22;a&#x22;, &#x22;b&#x22;))\n#> # A tibble: 4 × 3\n#>       a b         c\n#>   <int> <chr> <dbl>\n#> 1     1 a       0.5\n#> 2     2 b       1.5\n#> 3     3 <NA>    2.5\n#> 4     3 c      NA\n\" lang=\"r\"></i-code>\n<p>If you want to update existing values, use <code>rows_update()</code>. It will\nthrow an error if one of the rows to update does not exist:</p>\n<i-code value=\"df %>% rows_update(tibble(a = 3, b = &#x22;c&#x22;))\n#> Matching, by = &#x22;a&#x22;\n#> # A tibble: 3 × 3\n#>       a b         c\n#>   <int> <chr> <dbl>\n#> 1     1 a       0.5\n#> 2     2 b       1.5\n#> 3     3 c       2.5\n\ndf %>% rows_update(tibble(a = 4, b = &#x22;d&#x22;))\n#> Matching, by = &#x22;a&#x22;\n#> Error in &#x60;rows_update()&#x60;:\n#> ! &#x60;y&#x60; must contain keys that already exist in &#x60;x&#x60;.\n#> ℹ The following rows in &#x60;y&#x60; have keys that don&#x27;t exist in &#x60;x&#x60;: &#x60;c(1)&#x60;.\n#> ℹ Use &#x60;unmatched = &#x22;ignore&#x22;&#x60; if you want to ignore these &#x60;y&#x60; rows.\n\" lang=\"r\"></i-code>\n<p><code>rows_patch()</code> is a variant of <code>rows_update()</code> that will only update\nvalues in x that are <code>NA</code>.</p>\n<i-code value=\"df %>% rows_patch(tibble(a = 1:3, b = &#x22;patch&#x22;))\n#> Matching, by = &#x22;a&#x22;\n#> # A tibble: 3 × 3\n#>       a b         c\n#>   <int> <chr> <dbl>\n#> 1     1 a       0.5\n#> 2     2 b       1.5\n#> 3     3 patch   2.5\n\" lang=\"r\"></i-code>\n<p><code>row_upsert</code> update a df or insert new rows.</p>\n<i-code value=\"df %>%\n  rows_upsert(tibble(a = 3, b = &#x22;c&#x22;)) %>% # update\n  rows_upsert(tibble(a = 4, b = &#x22;d&#x22;)) # insert\n#> Matching, by = &#x22;a&#x22;\n#> Matching, by = &#x22;a&#x22;\n#> # A tibble: 4 × 3\n#>       a b         c\n#>   <int> <chr> <dbl>\n#> 1     1 a       0.5\n#> 2     2 b       1.5\n#> 3     3 c       2.5\n#> 4     4 d      NA\n\" lang=\"r\"></i-code>\n<h2>Context dependent expressions</h2>\n<p><code>n()</code> is a special function in dplyr which return the number of\nobservations in the current group. Now the new version comes with more\nsuch special functions, aka context dependent expressions. These\nfunctions return information about the “current” group or “current”\nvariable, so only work inside specific contexts like <code>summarize()</code> and\n<code>mutate()</code>. Specifically, a family of <code>cur_</code> functions are added:</p>\n<ul>\n<li>\n<p><code>cur_data()</code> gives the current data for the current group (exclusing\ngrouping variables, <code>cur_data_all</code> in developmental version returns\ngrouping variables as well)</p>\n</li>\n<li>\n<p><code>cur_group()</code> gives the group keys, a tibble with one row and one\ncolumn for each grouping variable.</p>\n</li>\n<li>\n<p><code>cur_group_id()</code> gives a unique numeric identifier for the current\ngroup</p>\n</li>\n<li>\n<p><code>cur_column()</code> gives the <strong>name</strong> of the current column (in <code>across()</code>\nonly).</p>\n</li>\n</ul>\n<i-code value=\"df <- tibble(\n  g = sample(rep(letters[1:3], 1:3)),\n  x = runif(6),\n  y = runif(6)\n)\ngf <- df %>% group_by(g)\n\ngf %>% summarize(row = cur_group_rows())\n#> Warning: Returning more (or less) than 1 row per &#x60;summarise()&#x60; group was deprecated in\n#> dplyr 1.1.0.\n#> ℹ Please use &#x60;reframe()&#x60; instead.\n#> ℹ When switching from &#x60;summarise()&#x60; to &#x60;reframe()&#x60;, remember that &#x60;reframe()&#x60;\n#>   always returns an ungrouped data frame and adjust accordingly.\n#> &#x60;summarise()&#x60; has grouped output by &#x27;g&#x27;. You can override using the &#x60;.groups&#x60;\n#> argument.\n#> # A tibble: 6 × 2\n#> # Groups:   g [3]\n#>   g       row\n#>   <chr> <int>\n#> 1 a         2\n#> 2 b         1\n#> 3 b         3\n#> 4 c         4\n#> 5 c         5\n#> 6 c         6\ngf %>% summarize(data = list(cur_group()))\n#> # A tibble: 3 × 2\n#>   g     data            \n#>   <chr> <list>          \n#> 1 a     <tibble [1 × 1]>\n#> 2 b     <tibble [1 × 1]>\n#> 3 c     <tibble [1 × 1]>\ngf %>% summarize(data = list(cur_data()))\n#> Warning: There was 1 warning in &#x60;summarize()&#x60;.\n#> ℹ In argument: &#x60;data = list(cur_data())&#x60;.\n#> ℹ In group 1: &#x60;g = &#x22;a&#x22;&#x60;.\n#> Caused by warning:\n#> ! &#x60;cur_data()&#x60; was deprecated in dplyr 1.1.0.\n#> ℹ Please use &#x60;pick()&#x60; instead.\n#> # A tibble: 3 × 2\n#>   g     data            \n#>   <chr> <list>          \n#> 1 a     <tibble [1 × 2]>\n#> 2 b     <tibble [2 × 2]>\n#> 3 c     <tibble [3 × 2]>\n# has nothing to do with groups\ngf %>% mutate(across(everything(), ~ paste(cur_column(), round(.x, 2))))\n#> # A tibble: 6 × 3\n#> # Groups:   g [3]\n#>   g     x      y     \n#>   <chr> <chr>  <chr> \n#> 1 b     x 0.2  y 0.75\n#> 2 a     x 0.74 y 0.63\n#> 3 b     x 0.21 y 0.12\n#> 4 c     x 0.62 y 0.12\n#> 5 c     x 0.39 y 0.63\n#> 6 c     x 0.79 y 0.85\n\" lang=\"r\"></i-code>\n<h2>Superseded functions</h2>\n<p><code>top_n()</code>, <code>sample_n()</code>, and <code>sample_frac()</code> have been superseded in\nfavor of a new family of slice helpers: <code>slice_min()</code>, <code>slice_max()</code>,\n<code>slice_head()</code>, <code>slice_tail()</code>, <code>slice_random()</code>.</p>\n<i-code value=\"# select penguins per group on body mass\npenguins_grouped %>%\n  slice_max(body_mass_g, n = 1)\n#> # A tibble: 3 × 8\n#> # Groups:   species [3]\n#>   species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n#>   <fct>     <fct>           <dbl>         <dbl>             <int>       <int>\n#> 1 Adelie    Biscoe           43.2          19                 197        4775\n#> 2 Chinstrap Dream            52            20.7               210        4800\n#> 3 Gentoo    Biscoe           49.2          15.2               221        6300\n#> # ℹ 2 more variables: sex <fct>, year <int>\n\npenguins_grouped %>%\n  slice_min(body_mass_g, n = 1)\n#> # A tibble: 4 × 8\n#> # Groups:   species [3]\n#>   species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n#>   <fct>     <fct>           <dbl>         <dbl>             <int>       <int>\n#> 1 Adelie    Biscoe           36.5          16.6               181        2850\n#> 2 Adelie    Biscoe           36.4          17.1               184        2850\n#> 3 Chinstrap Dream            46.9          16.6               192        2700\n#> 4 Gentoo    Biscoe           42.7          13.7               208        3950\n#> # ℹ 2 more variables: sex <fct>, year <int>\n\" lang=\"r\"></i-code>\n<i-code value=\"# random sampling\npenguins %>%\n  slice_sample(n = 10)\n#> # A tibble: 10 × 8\n#>    species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n#>    <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n#>  1 Adelie  Biscoe              41            20                 203        4725\n#>  2 Adelie  Torgersen           39.6          17.2               196        3550\n#>  3 Adelie  Torgersen           34.6          21.1               198        4400\n#>  4 Gentoo  Biscoe              43.2          14.5               208        4450\n#>  5 Adelie  Biscoe              38.2          18.1               185        3950\n#>  6 Gentoo  Biscoe              44            13.6               208        4350\n#>  7 Gentoo  Biscoe              43.3          14                 208        4575\n#>  8 Adelie  Dream               36            18.5               186        3100\n#>  9 Gentoo  Biscoe              53.4          15.8               219        5500\n#> 10 Adelie  Torgersen           34.6          17.2               189        3200\n#> # ℹ 2 more variables: sex <fct>, year <int>\n\npenguins %>%\n  slice_sample(prop = 0.1)\n#> # A tibble: 34 × 8\n#>    species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n#>    <fct>     <fct>           <dbl>         <dbl>             <int>       <int>\n#>  1 Adelie    Biscoe           35.7          16.9               185        3150\n#>  2 Gentoo    Biscoe           45.2          13.8               215        4750\n#>  3 Gentoo    Biscoe           46.1          13.2               211        4500\n#>  4 Adelie    Dream            40.6          17.2               187        3475\n#>  5 Gentoo    Biscoe           45.2          16.4               223        5950\n#>  6 Gentoo    Biscoe           45.5          15                 220        5000\n#>  7 Gentoo    Biscoe           46.8          16.1               215        5500\n#>  8 Chinstrap Dream            45.7          17                 195        3650\n#>  9 Gentoo    Biscoe           45            15.4               220        5050\n#> 10 Chinstrap Dream            52            18.1               201        4050\n#> # ℹ 24 more rows\n#> # ℹ 2 more variables: sex <fct>, year <int>\n\" lang=\"r\"></i-code>\n<p><code>summarize()</code> gains new argument <code>.groups</code> to control grouping structure\nof theh result.</p>\n<ul>\n<li>\n<p><code>.groups = \"drop_last\"</code> drops the last grouping level (i.e. the\ndefault behaviour).</p>\n</li>\n<li>\n<p><code>.groups = \"drop\"</code> drops all grouping levels and returns a tibble.</p>\n</li>\n<li>\n<p><code>.groups = \"keep\"</code> preserves the grouping of the input.</p>\n</li>\n<li>\n<p><code>.groups = \"rowwise\"</code> turns each row into its own group.</p>\n</li>\n</ul>\n<h2>Other changes</h2>\n<p>The new <code>rename_with()</code> makes it easier to rename variables\nprogrammatically:</p>\n<i-code value=\"penguins %>%\n  rename_with(stringr::str_to_upper)\n#> # A tibble: 344 × 8\n#>    SPECIES ISLAND    BILL_LENGTH_MM BILL_DEPTH_MM FLIPPER_LENGTH_MM BODY_MASS_G\n#>    <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n#>  1 Adelie  Torgersen           39.1          18.7               181        3750\n#>  2 Adelie  Torgersen           39.5          17.4               186        3800\n#>  3 Adelie  Torgersen           40.3          18                 195        3250\n#>  4 Adelie  Torgersen           NA            NA                  NA          NA\n#>  5 Adelie  Torgersen           36.7          19.3               193        3450\n#>  6 Adelie  Torgersen           39.3          20.6               190        3650\n#>  7 Adelie  Torgersen           38.9          17.8               181        3625\n#>  8 Adelie  Torgersen           39.2          19.6               195        4675\n#>  9 Adelie  Torgersen           34.1          18.1               193        3475\n#> 10 Adelie  Torgersen           42            20.2               190        4250\n#> # ℹ 334 more rows\n#> # ℹ 2 more variables: SEX <fct>, YEAR <int>\n\" lang=\"r\"></i-code>\n<p>You can optionally choose which columns to apply the transformation to\nwith the second argument:</p>\n<i-code value=\"penguins %>%\n  rename_with(stringr::str_to_upper, starts_with(&#x22;bill&#x22;))\n#> # A tibble: 344 × 8\n#>    species island    BILL_LENGTH_MM BILL_DEPTH_MM flipper_length_mm body_mass_g\n#>    <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n#>  1 Adelie  Torgersen           39.1          18.7               181        3750\n#>  2 Adelie  Torgersen           39.5          17.4               186        3800\n#>  3 Adelie  Torgersen           40.3          18                 195        3250\n#>  4 Adelie  Torgersen           NA            NA                  NA          NA\n#>  5 Adelie  Torgersen           36.7          19.3               193        3450\n#>  6 Adelie  Torgersen           39.3          20.6               190        3650\n#>  7 Adelie  Torgersen           38.9          17.8               181        3625\n#>  8 Adelie  Torgersen           39.2          19.6               195        4675\n#>  9 Adelie  Torgersen           34.1          18.1               193        3475\n#> 10 Adelie  Torgersen           42            20.2               190        4250\n#> # ℹ 334 more rows\n#> # ℹ 2 more variables: sex <fct>, year <int>\n\" lang=\"r\"></i-code>\n<p><code>mutate()</code> gains argument <code>.keep</code> that allows you to control which\ncolumns are retained in the output:</p>\n<i-code value=\"penguins %>% mutate(\n  double_mass = body_mass_g * 2,\n  island_lower = stringr::str_to_lower(island),\n  .keep = &#x22;used&#x22;\n)\n#> # A tibble: 344 × 4\n#>    island    body_mass_g double_mass island_lower\n#>    <fct>           <int>       <dbl> <chr>       \n#>  1 Torgersen        3750        7500 torgersen   \n#>  2 Torgersen        3800        7600 torgersen   \n#>  3 Torgersen        3250        6500 torgersen   \n#>  4 Torgersen          NA          NA torgersen   \n#>  5 Torgersen        3450        6900 torgersen   \n#>  6 Torgersen        3650        7300 torgersen   \n#>  7 Torgersen        3625        7250 torgersen   \n#>  8 Torgersen        4675        9350 torgersen   \n#>  9 Torgersen        3475        6950 torgersen   \n#> 10 Torgersen        4250        8500 torgersen   \n#> # ℹ 334 more rows\n\npenguins %>% mutate(double_mass = body_mass_g * 2, .keep = &#x22;none&#x22;)\n#> # A tibble: 344 × 1\n#>    double_mass\n#>          <dbl>\n#>  1        7500\n#>  2        7600\n#>  3        6500\n#>  4          NA\n#>  5        6900\n#>  6        7300\n#>  7        7250\n#>  8        9350\n#>  9        6950\n#> 10        8500\n#> # ℹ 334 more rows\n\" lang=\"r\"></i-code>\n<h2>Use cases</h2>\n<p>This in-progress section documents tasks that would otherwise been\nimpossible or laborious with previous version of dplyr.</p>\n<h3>Replace missing values in many columns</h3>\n<p>Since <code>tidyr::replace_na</code> does not support tidy select syntax, replacing\nNA values in multiple columns could be a drudgery. Now this is made easy\nwith <code>coalesce</code> and <code>across</code></p>\n<i-code value=\"penguins %>% summarize(across(starts_with(&#x22;bill&#x22;), ~ sum(is.na(.x))))\n#> # A tibble: 1 × 2\n#>   bill_length_mm bill_depth_mm\n#>            <int>         <int>\n#> 1              2             2\n\npenguins %>%\n  mutate(across(starts_with(&#x22;bill&#x22;), ~ coalesce(.x, 0))) %>%\n  summarize(across(starts_with(&#x22;bill&#x22;), ~ sum(is.na(.x))))\n#> # A tibble: 1 × 2\n#>   bill_length_mm bill_depth_mm\n#>            <int>         <int>\n#> 1              0             0\n\" lang=\"r\"></i-code>\n<h3>Rolling regression</h3>\n<p><code>cur_data()</code> is particularly useful for rolling regression, in\nconjunction with the <a href=\"https://davisvaughan.github.io/slider/\">slider</a>\npackage.</p>\n<i-code value=\"library(slider)\nlibrary(lubridate)\n#> \n#> Attaching package: &#x27;lubridate&#x27;\n#> The following objects are masked from &#x27;package:base&#x27;:\n#> \n#>     date, intersect, setdiff, union\n# historical stock prices from 2014-2018 for Google, Amazon, Facebook and Apple\nstock <- tsibbledata::gafa_stock %>% select(Symbol, Date, Close, Volume)\nstock\n#> # A tibble: 5,032 × 4\n#>    Symbol Date       Close    Volume\n#>    <chr>  <date>     <dbl>     <dbl>\n#>  1 AAPL   2014-01-02  79.0  58671200\n#>  2 AAPL   2014-01-03  77.3  98116900\n#>  3 AAPL   2014-01-06  77.7 103152700\n#>  4 AAPL   2014-01-07  77.1  79302300\n#>  5 AAPL   2014-01-08  77.6  64632400\n#>  6 AAPL   2014-01-09  76.6  69787200\n#>  7 AAPL   2014-01-10  76.1  76244000\n#>  8 AAPL   2014-01-13  76.5  94623200\n#>  9 AAPL   2014-01-14  78.1  83140400\n#> 10 AAPL   2014-01-15  79.6  97909700\n#> # ℹ 5,022 more rows\n\" lang=\"r\"></i-code>\n<i-code value=\"# Arrange and group by &#x60;Symbol&#x60; (i.e. Google)\nstock <- stock %>%\n  arrange(Symbol, Date) %>%\n  group_by(Symbol)\n\nlinear_model <- function(df) {\n  lm(Close ~ Volume, data = df)\n}\n\n# 10 day rolling regression per group\nstock %>%\n  mutate(model = slide_index(\n    cur_data(),\n    Date,\n    linear_model,\n    .before = days(9),\n    .complete = TRUE\n  ))\n#> # A tibble: 5,032 × 5\n#> # Groups:   Symbol [4]\n#>    Symbol Date       Close    Volume model \n#>    <chr>  <date>     <dbl>     <dbl> <list>\n#>  1 AAPL   2014-01-02  79.0  58671200 <NULL>\n#>  2 AAPL   2014-01-03  77.3  98116900 <NULL>\n#>  3 AAPL   2014-01-06  77.7 103152700 <NULL>\n#>  4 AAPL   2014-01-07  77.1  79302300 <NULL>\n#>  5 AAPL   2014-01-08  77.6  64632400 <NULL>\n#>  6 AAPL   2014-01-09  76.6  69787200 <NULL>\n#>  7 AAPL   2014-01-10  76.1  76244000 <NULL>\n#>  8 AAPL   2014-01-13  76.5  94623200 <lm>  \n#>  9 AAPL   2014-01-14  78.1  83140400 <lm>  \n#> 10 AAPL   2014-01-15  79.6  97909700 <lm>  \n#> # ℹ 5,022 more rows\n\" lang=\"r\"></i-code>",
    "slug": "a-taste-of-dplyr-100"
  },
  {
    "title": "Generating dynamic contents in R Markdown and Quarto",
    "date": "2023-01-22T00:00:00.000Z",
    "slug": "dynamic-rmd-quarto",
    "description": "Automate report generation in Quarto with Knitr\n",
    "metadata": {
      "readingTime": 4,
      "wordCount": 952
    },
    "draft": false,
    "content": "<p>A common scenario in my day-to-day data analysis is that I have many\nobjects that are typically data frames, and for each of them I want to\ncreate a new section in my Quarto/R Markdown document with their\nrespective summary statistics. The set of operations to apply are\nusually the same, just the data is different. A manual way of doing this\nwould be copy-pasting the same chunk of code for generating the\nsummaries, and only change the variable name. For instance:</p>\n<i-code value=\"\n## Section for Data A\n\nData A has &#x60;r nrow(data_a)&#x60; rows and &#x60;r ncol(data_a)&#x60; columns.\n\n&#x60;&#x60;&#x60;{r}\nsummary_fn(data_a)\n&#x60;&#x60;&#x60;\n\n## Section for Data B\n\nData B has &#x60;r nrow(data_b)&#x60; rows and &#x60;r ncol(data_b)&#x60; columns.\n\n&#x60;&#x60;&#x60;{r}\nsummary_fn(data_b)\n&#x60;&#x60;&#x60;\n\n## Section for Data C\n\n...\n\" lang=\"markdown\"></i-code>\n<p>This becomes a pain when they are just so many objects and I have to\nchange the name one by one. This post introduces a programmatic way of\nautomating this task using <code>knit_child</code> from the <code>knitr</code> rendering\nengine.</p>\n<h2>Using the <code>knitr</code> engine</h2>\n<p>The <code>knitr</code> engine has built-in supports for dyanmic, parameterized\ndocuments. For R Markdown, you can pass data to the document using the\n<code>params</code> argument in <code>rmarkdown::render()</code>, learn more at\n<a href=\"https://bookdown.org/yihui/rmarkdown/parameterized-reports.html\">https://bookdown.org/yihui/rmarkdown/parameterized-reports.html</a>. This\nis intented for rendering one big parameterized <code>.Rmd</code> document.</p>\n<p>When it comes to inserting subcontents into either <code>.qmd</code> or <code>.Rmd</code>\nfiles, <code>knitr:::knit_child</code> is the function you need. Similar to\n<code>params</code> in <code>rmarkdown::render</code>, you can pass a environment object to\n<code>knitr:::knit_child</code> using the <code>envir</code> argument. The returned value of\n<code>knit_child</code> is simply the character string that can be directly\nembedded into a documnet, it’s also used in conjunction with the chunk\noption <code>output = 'asis'</code> (Quarto) or <code>results = 'asis'</code> (R Markdown),</p>\n<p><code>knit_child</code> accepts both an inline string <code>text</code> or a file path <code>file</code>.\nBelow we use the inline string to generate a summary of the <code>iris</code> data\nframe.</p>\n<i-code value=\"&#x60;&#x60;&#x60;{r}\n# chunk option output = &#x27;asis&#x27;\nres <- knitr::knit_child(text = c(\n    &#x27;&#x60;&#x60;&#x60;{r}&#x27;,\n    &#x27;summary(data)&#x27;,\n    &#x27;&#x60;&#x60;&#x60;&#x27;\n  ), envir = rlang::env(data = iris), quiet = TRUE)\ncat(res, sep = &#x22;\\n&#x22;)\n&#x60;&#x60;&#x60;\n\" lang=\"markdown\"></i-code>\n<i-code value=\"summary(data)\n#>   Sepal.Length   Sepal.Width    Petal.Length   Petal.Width        Species  \n#>  Min.   :4.30   Min.   :2.00   Min.   :1.00   Min.   :0.1   setosa    :50  \n#>  1st Qu.:5.10   1st Qu.:2.80   1st Qu.:1.60   1st Qu.:0.3   versicolor:50  \n#>  Median :5.80   Median :3.00   Median :4.35   Median :1.3   virginica :50  \n#>  Mean   :5.84   Mean   :3.06   Mean   :3.76   Mean   :1.2                  \n#>  3rd Qu.:6.40   3rd Qu.:3.30   3rd Qu.:5.10   3rd Qu.:1.8                  \n#>  Max.   :7.90   Max.   :4.40   Max.   :6.90   Max.   :2.5\n\" lang=\"r\"></i-code>\n<p>All these combined, we could divide the job into a main document\n<code>main.Rmd</code> and a template document <code>_template.Rmd</code>. In the main\ndocument, we collect all the data, loop through them and insert them\ninto the template document using <code>knitr:::knit_child</code>. Then we can use\nthe <code>asis</code> output option to include the template document into the main\ndocument.</p>\n<div class=\"column-margin\">\n<p>This will also work for Quarto documents as long as we are using the\nknitr engine.</p>\n</div>\n<p>The example main and template documents are shown below:</p>\n<div class=\"two-column wider\">\n<div class=\"div\">\n<p>In <code>main.Rmd</code></p>\n<i-code value=\"---\ntitle: &#x22;Dynamic contents in R Markdown and Quarto with &#x60;knit_child()&#x60;&#x22;\ntoc: true\n---\n\nGenerate random dataset\n\n&#x60;&#x60;&#x60;{r}\nrandom_data <- function(n) {\n  data.frame(\n    x = rnorm(n),\n    y = rnorm(n)\n  )\n}\n&#x60;&#x60;&#x60;\n\n&#x60;&#x60;&#x60;{r}\nall_data <- purrr::map(1:5, ~ random_data(round(runif(1, 10, 100))))\n&#x60;&#x60;&#x60;\n\n&#x60;&#x60;&#x60;{r}\nrender_child <- function(data, i) {\n  res = knitr::knit_child(\n   text = xfun::read_utf8(&#x22;_template.Rmd&#x22;),\n   envir = rlang::env(data = data, i = i),\n   quiet = TRUE\n  )\n  cat(res, sep = &#x27;\\n&#x27;)\n  cat(&#x22;\\n&#x22;)\n}\n&#x60;&#x60;&#x60;\n\nHere is a list of reports\n\n&#x60;&#x60;&#x60;{r}\npurrr::iwalk(all_data, render_child)\n&#x60;&#x60;&#x60;\n\"></i-code>\n</div>\n<div class=\"div\">\n<p>In <code>_template.Rmd</code></p>\n<i-code value=\"## Dataset &#x60;r i&#x60;\n\nDataset &#x60;r i&#x60; has &#x60;r nrow(data)&#x60; rows.\n\n### Summary\n\n&#x60;&#x60;&#x60;{r}\nsummary(data)\n&#x60;&#x60;&#x60;\n\n### Plot\n\n&#x60;&#x60;&#x60;{r}\nplot(data)\n&#x60;&#x60;&#x60;\n\"></i-code>\n</div>\n</div>\n<p>I’ve defined a wrapper function <code>render_child()</code> that uses\n<code>knit_child()</code> under the hood. The key is you can pass arbitrary values\nusing the <code>envir</code> argument. Whatever you need in the template document,\nyou can pass them in as a named list and convert them into an\nenvironment object using <code>rlang::env()</code>.</p>\n<p>When you run the main document, it will generate a list of random data\nframes, generate a child document for each using the template document,\nand inserts the result back to the main document. The result is shown\nbelow:</p>\n<div class=\"column-body-outset\" style=\"border: 3px solid #627891; padding: 20px; height: 900px\">\n<iframe src=\"https://bookdown.org/qiushi/dynamic_contents_in_r_markdown_with_knit_child/\" frameborder=\"0\" style=\"width:100%;height:100%\">\n</iframe>\n</div>\n<h2>A note on <code>knitr::knit_expand</code></h2>\n<p><a href=\"https://bookdown.org/yihui/rmarkdown-cookbook/knit-expand.html\">R Markdown\nCookbook</a>\nalso introduces a function called <code>knitr::knit_expand()</code> that can be\nused to insert contents into a template content. An example is shown\nbelow:</p>\n<i-code value=\"knitr::knit_expand(\n  text = &#x22;The value of &#x60;a&#x60; is {{a}}&#x22;,\n  a = 1\n)\n#> [1] &#x22;The value of &#x60;a&#x60; is 1&#x22;\n\" lang=\"r\"></i-code>\n<p>Since you can also pass in a <code>file</code> argument in <code>knit_expand</code>, I was\ntempted to use this function with <code>knit_child</code> when I started to write\nthis post. For example</p>\n<i-code value=\"res <- knnitr::knit_expand(\n  file = &#x22;template.Rmd&#x22;\n  data = iris[1:5, ]\n)\n\" lang=\"r\"></i-code>\n<p>Then you can access <code>iris</code> in the template document like so</p>\n<i-code value=\"---\ntitle: template document\n---\n\n&#x60;&#x60;&#x60;{r}\n{{ data }}\n&#x60;&#x60;&#x60;\n\" lang=\"markdown\"></i-code>\n<p>But this will not work. <code>knitr::knit_expand</code> simply finds all the\nplaceholders marked by <code>{ }</code>, interpolates them and then pass the text\nto the knitting functions. This mechanism works fine you only need to\ninsert simple primitives, such as strings and numbers, but not if you\nwant to pass data.frames or other complex objects in general. Then the\nknitting functions will see a code chunk like this</p>\n<i-code value=\"&#x60;&#x60;&#x60;{r}\nc(5.1, 4.9, 4.7, 4.6, 5)\nc(3.5, 3, 3.2, 3.1, 3.6)\nc(1.4, 1.4, 1.3, 1.5, 1.4)\nc(0.2, 0.2, 0.2, 0.2, 0.2)\nc(1, 1, 1, 1, 1)\n&#x60;&#x60;&#x60;\n\" lang=\"markdown\"></i-code>\n<p>which is not valid R syntax.</p>\n<h2>Without <code>knitr</code></h2>\n<p>It you are using Quarto with a different engine than <code>knitr</code>, I found no\nsimilar construct as <code>knitr::knit_child</code>. Although Quarto offers a\nnative <a href=\"https://quarto.org/docs/authoring/variables.html\">variables</a>\nmechanism for reading values from configuration files, it’s more\nsuitable for static data shared across many documents. It also suffers\nthe same problem as <code>knitr::knit_expand</code> that you are limited to\nwhatever data structure that is supported by YAML.</p>"
  },
  {
    "title": "Git tricks",
    "date": "2024-07-23T00:00:00.000Z",
    "description": "Useful git tricks that simplifies daily commit workflows\n",
    "metadata": {
      "readingTime": 1,
      "wordCount": 87
    },
    "draft": true,
    "content": "<p><a href=\"https://www.youtube.com/watch?v=e6ZI6AmlHN4\">https://www.youtube.com/watch?v=e6ZI6AmlHN4</a></p>\n<h2>Reverting changes with <code>reset</code> and <code>restore</code></h2>\n<p><a href=\"https://stackoverflow.com/questions/58003030/what-is-git-restore-and-how-is-it-different-from-git-reset\">https://stackoverflow.com/questions/58003030/what-is-git-restore-and-how-is-it-different-from-git-reset</a></p>\n<h2>Filters</h2>\n<p><a href=\"https://git-scm.com/book/en/v2/Customizing-Git-Git-Attributes\">https://git-scm.com/book/en/v2/Customizing-Git-Git-Attributes</a></p>\n<h2>Fixup commits</h2>\n<p><a href=\"https://thoughtbot.com/blog/autosquashing-git-commits\">https://thoughtbot.com/blog/autosquashing-git-commits</a></p>\n<i-code value=\"git commit --fixup=<commit>\ngit rebase --autosquash\n\" lang=\"bash\"></i-code>\n<h2>Scalar</h2>\n<i-code value=\"scalar clone <larg-repo>\n\" lang=\"bash\"></i-code>\n<h2>Worktrees</h2>\n<p>work in a branch in a separate directory</p>\n<i-code value=\"git worktree add -b bugfix ../another-directory\n\" lang=\"bash\"></i-code>\n<p><a href=\"https://git-scm.com/docs/git-worktree\">https://git-scm.com/docs/git-worktree</a></p>",
    "slug": "git-tricks"
  },
  {
    "title": "Structural pattern matching in Python 3.10",
    "date": "2022-02-20T00:00:00.000Z",
    "slug": "python310-pattern-matching",
    "description": "Pattern matching with `match ... case` is an exciting feature added in Python 3.10. This article reviews the syntax and shows some practical examples.\n",
    "metadata": {
      "readingTime": 4,
      "wordCount": 1139
    },
    "draft": false,
    "content": "<h2>Introduction</h2>\n<p><a href=\"https://www.python.org/dev/peps/pep-0634/\">Structural Pattern Matching</a>\nis a new feature introduced in python\n<a href=\"https://docs.python.org/3/whatsnew/3.10.html\">3.10</a>, and perhaps the\nmost intriguing one. It takes as input an object to inspect (following\n<i-inline-code value=\"match\" lang=\"py\"></i-inline-code>), and multiple patterns to match against (following one or\nmore <i-inline-code value=\"case\" lang=\"py\"></i-inline-code>). If there is a match, a pattern-specific code block\nruns. The basic syntax is</p>\n<i-code value=\"error_code = 403\nmatch error_code:\n    case 400:\n        print(&#x22;Bad request&#x22;)\n    case 403:\n        print(&#x22;Unauthorized&#x22;)\n    case 500:\n        print(&#x22;Internal server error&#x22;)\n# !callout[/case _/] the default case when none of the above matches :right\n    case _:\n        print(&#x22;Something&#x27;s wrong with the Internet&#x22;)\n#> Unauthorized\n\" lang=\"python\"></i-code>\n<p>Here, we check case by case if <code>error_code</code> is equal to a value, if it’s\nnot one of 400, 403, 500, <code>_</code> will be a catch-all wildcard. Also,\npattern matching will break when it hits a match, so each <code>case</code> should\nbe independent.</p>\n<p>To run examples in this article, be sure you are using python higher\nthan 3.10. To check, use</p>\n<i-code value=\"import sys\nsys.version\n#> &#x27;3.10.14 (main, Mar 19 2024, 21:46:16) [Clang 15.0.0 (clang-1500.3.9.4)]&#x27;\n\" lang=\"python\"></i-code>\n<h2>Pattern matching as a replacement for switch statements</h2>\n<p>The most apparent usage of pattern matching is implementing\n<code>switch ... case</code> statements in many other programming languages, which\nis a replacement for multiple if else statements. Imagine we are\nbuilding a game, and we have a <code>move</code> function for controlling figure\nmovement.</p>\n<i-code value=\"def move(self, direction):\n    match direction:\n        case &#x22;up&#x22;:\n            self.move_up()\n        case &#x22;down&#x22;:\n            self.move_down()\n        case &#x22;left&#x22;:\n            self.move_left()\n        case &#x22;right&#x22;:\n            self.move_right()\n\" lang=\"python\"></i-code>\n<h2>Match dictionaries and lists</h2>\n<p>The real power of pattern matching resides in destructuring data\nstructures like lists and dictionaries.</p>\n<i-code value=\"match {&#x22;first_name&#x22;: &#x22;Jane&#x22;, &#x22;last_name&#x22;: &#x22;Doe&#x22;, &#x22;middle_name&#x22;: &#x22;&#x22;}:\n    case {&#x22;first_name&#x22;: first_name , &#x22;last_name&#x22;: last_name}:\n        print(first_name, last_name)\n#> Jane Doe\n\" lang=\"python\"></i-code>\n<p>In the example above, we supplied a pattern that says the object should\ncontains keys “first_name” and “last_name”, if the pattern matches,\ntheir values will be captured into the variables <code>first_name</code> and\n<code>last_name</code>. Note that for an dictionary, structural pattern matching\nmatches the structure instead of the exact content, the pattern is valid\nas long as “first_name” and “last_name” are one of the object’s keys,\nany unmentioned keys, like “middle_name”, will be ignored.</p>\n<p>For a more advanced example, suppose we are working with the <a href=\"https://docs.spacexdata.com/\">SpaceX\nAPI</a> to retrieve launch data, an\nindividual record of launch looks like</p>\n<i-code value=\"{\n        &#x22;flight_number&#x22;: 1,\n        &#x22;mission_name&#x22;: &#x22;FalconSat&#x22;,\n        &#x22;upcoming&#x22;: false,\n        &#x22;launch_year&#x22;: &#x22;2006&#x22;,\n        &#x22;launch_date_unix&#x22;: 1143239400,\n        &#x22;rocket&#x22;: {\n            &#x22;rocket_id&#x22;: &#x22;falcon1&#x22;,\n            &#x22;rocket_name&#x22;: &#x22;Falcon 1&#x22;,\n        },\n        &#x22;details&#x22;: &#x22;Engine failure at 33 seconds and loss of vehicle&#x22;,\n        //... other fields\n}\n\" lang=\"json\"></i-code>\n<p>We only want to get the fields <code>mission_name</code>, <code>rocket_name</code> and\n<code>details</code>. Note that</p>\n<i-code value=\"import requests\nimport json\nfrom pprint import pp\nres = requests.get(&#x22;https://api.spacexdata.com/v3/launches?limit=3&#x22;)\ndata = res.json()\nout = []\nfor launch in data:\n    match launch:\n        case {&#x22;mission_name&#x22;: mname, &#x22;rocket&#x22;: {&#x22;rocket_name&#x22;: rname}, &#x22;details&#x22;: details}:\n            out.append({&#x22;mission_name&#x22;: mname, &#x22;rocket_name&#x22;: rname, &#x22;details&#x22;: details})\n\npp(out)\n\" lang=\"python\"></i-code>\n<i-code value=\"#> [{&#x27;mission_name&#x27;: &#x27;FalconSat&#x27;,\n#>   &#x27;rocket_name&#x27;: &#x27;Falcon 1&#x27;,\n#>   &#x27;details&#x27;: &#x27;Engine failure at 33 seconds and loss of vehicle&#x27;},\n#>  {&#x27;mission_name&#x27;: &#x27;DemoSat&#x27;,\n#>   &#x27;rocket_name&#x27;: &#x27;Falcon 1&#x27;,\n#>   &#x27;details&#x27;: &#x27;Successful first stage burn and transition to second stage, &#x27;\n#>              &#x27;maximum altitude 289 km, Premature engine shutdown at T+7 min 30 &#x27;\n#>              &#x27;s, Failed to reach orbit, Failed to recover first stage&#x27;},\n#>  {&#x27;mission_name&#x27;: &#x27;Trailblazer&#x27;,\n#>   &#x27;rocket_name&#x27;: &#x27;Falcon 1&#x27;,\n#>   &#x27;details&#x27;: &#x27;Residual stage 1 thrust led to collision between stage 1 and &#x27;\n#>              &#x27;stage 2&#x27;}]\n\"></i-code>\n<p>Here, not only are we matching top level key <code>mission_name</code> and\n<code>details</code>, we also use a nested pattern to extract rocket name.</p>\n<p>You can also match on a list.</p>\n<i-code value=\"match [1, 2, 3]:\n    case [1, 2]:\n        print(&#x22;match 1&#x22;)\n# !callout[/\\*rest/] match the the rest of elements\n    case [2, *rest]:\n        print(&#x22;match 2&#x22;)\n        print(rest)\n# !callout[/\\*other/] match elements except the last one\n    case[*other, last]:\n        print(&#x22;match 3&#x22;)\n        print(last)\n        print(other)\n#> match 3\n#> 3\n#> [1, 2]\n\" lang=\"python\"></i-code>\n<p>I mentioned that pattern matching for dict does not require use to\nexplicitly declare all fields. For lists this is different, we have to\ndeclare all elements, this is why match 1 fails. Match 2 attempts to use\nthe <code>*</code> syntax to capture all values after 2 into a list called <code>rest</code>.\nThis is helpful in case the list is really large and it’s impossible to\nexhaust all elements, or we simply don’t care about some elements.\nHowever, the second pattern does not specify the correct order, as 2 is\nnot the first element in the matching object. Match 3 captures all\nelements but the last into <code>other</code>, and assign the last element to\n<code>last</code>.</p>\n<p>It’s also possible to express <code>or</code> logic with <code>|</code> in case statement. For\nexample, we may add a <code>case 401 | 403 | 404: \"Not allowed\"</code> statement to\nour first example. Here is another example from pep:</p>\n<i-code value=\"match command.split():\n    ... # Other cases\n    case [&#x22;north&#x22;] | [&#x22;go&#x22;, &#x22;north&#x22;]:\n        current_room = current_room.neighbor(&#x22;north&#x22;)\n    case [&#x22;get&#x22;, obj] | [&#x22;pick&#x22;, &#x22;up&#x22;, obj] | [&#x22;pick&#x22;, obj, &#x22;up&#x22;]:\n        ... # Code for picking up the given object\n\" lang=\"python\"></i-code>\n<p>Literal patterns can also be captured using the <code>as</code> keyword</p>\n<i-code value=\"match command.split():\n    case [&#x22;go&#x22;, (&#x22;north&#x22; | &#x22;south&#x22; | &#x22;east&#x22; | &#x22;west&#x22;) as direction]:\n        current_room = current_room.neighbor(direction)\n\" lang=\"python\"></i-code>\n<h2>Add conditions</h2>\n<p>Pattern matching allows if conditions the same way as list\ncomprehension, we can append an <i-inline-code value=\"if ... else\" lang=\"py\"></i-inline-code> clause like so</p>\n<i-code value=\"all_directions = [&#x22;up&#x22;, &#x22;down&#x22;]\n\nmatch commad.split():\n    case [&#x22;go&#x22;, direction] if direction in all_directions:\n        move(direction)\n    case [&#x22;go&#x22;, _]:\n        print(&#x22;direction not supported&#x22;)\n\" lang=\"python\"></i-code>\n<p>For conditions that checks if an object is of a data type, we can\ndirectly use the class creator function:</p>\n<i-code value=\"def sum_list(numbers):\n    match numbers:\n        case []:\n            return 0\n        case [int(first) | float(first), *rest]:\n            return first + sum_list(rest)\n        case _:\n            raise ValueError(f&#x22;Can only sum lists of numbers&#x22;)\n\nsum_list([1, 2, 3])\n#> 6\nsum_list([1, &#x22;2&#x22;, 3])\n#> Can only sum lists of numbers\n\" lang=\"python\"></i-code>\n<p>Here <i-inline-code value=\"int(first) | float(first)\" lang=\"py\"></i-inline-code> checks if the first element is an\ninteger or float. The next example uses a <code>dataclass</code> based pattern as\nwell as its attributes</p>\n<i-code value=\"from dataclasses import dataclass\n\n@dataclass\nclass Point:\n    x: float\n    y: float\n\np = Point(x = 1, y = 1)\n# data class for validation\nmatch p:\n    case Point(x = x):\n        print(x)\n#> 1\n\" lang=\"python\"></i-code>\n<p>In general, any class can be used for validation. This is also called a\n<strong>class pattern</strong>.</p>\n<h2>Matching constants</h2>\n<p>Care should be taken when matching constants, since it’s common to store\nthe constant in an variable and then use it in <code>case</code>. The following\ncode will not work:</p>\n<i-code value=\"direction = &#x22;up&#x22;\n\nmatch &#x22;down&#x22;:\n# !callout[/direction/] capture &#x22;up&#x22; into the variable &#x60;direction&#x60; :right\n    case direction:\n        print(&#x22;match&#x22;)\n    case _:\n        print(&#x22;no match&#x22;)\n\" lang=\"python\"></i-code>\n<p>We are trying to match the value “up”, but python interprets it as a\ncapture pattern that says store whatever the match object is into the\nvariable <code>direction</code>, so we are effectively overriding <code>direction</code>\n(recall the list matching example) and the first case always matches.\nPython will not allow this with an error message\n<code>SyntaxError: name capture 'direction' makes remaining patterns unreachable</code>.</p>\n<p>As an alternative to matching literal values, we can use an enum type\nfor constant matching instead</p>\n<i-code value=\"import enum\nclass Direction(str, enum.Enum):\n    up = &#x22;up&#x22;\n    down = &#x22;down&#x22;\n\nmatch &#x22;down&#x22;:\n    case Direction.up:\n        print(&#x22;match 1&#x22;)\n    case Direction.down:\n        print(&#x22;match 2&#x22;)\n    case _:\n        print(&#x22;match 3&#x22;)\n#> match 2\n\" lang=\"python\"></i-code>"
  },
  {
    "title": "Developing htmlwidgets in R with TypeScript and esbuild",
    "date": "2022-01-29T00:00:00.000Z",
    "description": "Frontend tools that add type safety and speed to htmlwidgets development.\n",
    "metadata": {
      "readingTime": 6,
      "wordCount": 1620
    },
    "draft": false,
    "content": "<my-callout>\n<p>This post assumes familiarity R package development, JavaScript and\nNode.js. I recommend the second chapter of\n<a href=\"https://book.javascript-for-r.com\">JavaScript for R</a> as a\nstarter.</p>\n</my-callout>\n<p>The <code>htmlwidgets</code> R package provides a friendly interface for developing\nR packages that wraps JavaScript libraries. An htmlwidget is nothing\nmore than a normal R plot plus interactivity powered by JavaScript. The\npackage abstracts away many of the details of juggling with both\nJavaScript and R, most notable of which being dependency management.</p>\n<p>An example from the <a href=\"https://book.javascript-for-r.com/\">JavaScript for\nR</a> book shows the development of the\n<a href=\"https://github.com/JohnCoene/gior\"><code>gior</code></a> package, which corresponds\nto the <a href=\"https://giojs.org/\"><code>gio.js</code></a> JavaScript library. The\n<a href=\"https://github.com/JohnCoene/gior/tree/master/inst/htmlwidgets\"><code>inst/htmlwidgets</code></a>\ndirectory contains necessary dependencies required by <code>gio.js</code>. This\nfile is the entry point of creating the widget. It depends on JavaScript\nlibraries including <code>gio.js</code>, <code>three.js</code>, <code>HTMLWidgets</code> and <code>Shiny</code>. We\ndon’t need to worry about including <code>HTMLWidgets</code> or <code>Shiny</code> ourselves,\nsince R will do it for us.</p>\n<p>For the first two dependencies, we can download it from CDN and include\nit in the\n<a href=\"https://github.com/JohnCoene/gior/tree/master/inst/htmlwidgets/lib\"><code>inst/htmlwidgets/lib</code></a>\ndirectory. Lastly, we include a file\n<a href=\"https://github.com/JohnCoene/gior/blob/master/inst/htmlwidgets/gior.yaml\"><code>gior.yaml</code></a>\nto declare locations of the dependencies that looks like:</p>\n<i-code value=\"dependencies:\n - name: three\n   version: 97\n   src: htmlwidgets/lib/three\n   script: three.min.js\n - name: gio\n   version: 2.0\n   src: htmlwidgets/lib/gio-2.0\n   script: gio.min.js\n\" lang=\"yaml\" filename=\" gior.yaml\"></i-code>\n<p>Now, whenever we create a widget from R, the rendering context will\nautomatically serve all the javascript files. This workflow is\nconvenient for developing pacakges that does not require much work on\nthe JavaScript side, all we need to do is calling some initialization\nfunctions in <code>gior.js</code>. However, if more work on the javascript side is\ninvolved, more than just passing a few lines of options, this setup is\nnot sufficient. Since javascript dependencies are managed from R and\nnever decalred in <code>gior.js</code>, we won’t be getting all the nice features a\nmodern text editor can provide, such as autocompletion, snippets,\nlinking and intellisense. Moreover, when our package gets larger we\nmight want to split the javascript code into separate modules rather\nthan cluttering the <code>gior.js</code> file, and it’s not so fun to do bundling\nourselves.</p>\n<p>For this reason, it makes sense to have more control over how javascript\ndependencies are managed, rather than just downloding and including a\ndist file. The end result is still the same, we need to include one or\nseveral javascript files for the plot. It’s just we will not be using\nfiles already provided by cdn, but to download the javascript package\nand do the bundling ourselves. The\n<a href=\"https://github.com/JohnCoene/packer\"><code>packer</code></a> package provides an\nsolution to this.</p>\n<h2>The <code>packer</code> package</h2>\n<p>In the JavaScript world, dependency management is done through node and\na package manager of choice, like npm, yarn or pnpm. These package\nmanagers call be used to create a project-specific environment into\nwhich various packages will be insalled. Then, we would use a bundler\nlike webpack to extract all files into a single file, which is served\nevery time a widget is created from R. <code>packer</code> can be used to scaffold\na project structure for this need, and provides an R interface so that\nwe can still do all the work through R commands. The following two\ncommands scaffold an htmlwidgets package powered by packer:</p>\n<i-code value=\"usethis::create_package(&#x22;<package-name>&#x22;)\npacker::scaffold_widget(&#x22;<widget-name>&#x22;)\n\" lang=\"r\"></i-code>\n<p>The project directory tree is generated as</p>\n<i-code value=\"├── DESCRIPTION\n├── NAMESPACE\n├── R\n│   ├── <widget-name>.R\n├── inst\n│   └── packer\n├── node_modules\n│   └── ...\n├── package.json\n├── srcjs\n│   ├── config\n│   ├── inputs\n│   └── index.js\n├── webpack.common.js\n├── webpack.dev.js\n└── webpack.prod.js\n\"></i-code>\n<p>A <code>node_modules</code> folder is created for storing javascript dependencies.\nNote that we are managing javascript dependencies ourselves now, and we\ncan install them with <code>packer::yarn_install</code> from R or simply <code>yarn add</code>\nfrom the command line.</p>\n<p>The three files started with <code>webpack</code> are webpack configurations for\nbundling. The <code>webpack.common.js</code> file stores shared options for both\ndevelopment and production. The <code>webpack.dev.js</code> is used for\ndevelopment, and the <code>webpack.prod.js</code> is used for production. There are\n3 most important webpack options for our purposes, which packer sets in\nthe <code>srcjs/config</code> directory.</p>\n<ul>\n<li>\n<p><code>output</code> will determine the dist file name and location, this should\nbe named <code>&#x3C;widget-name>.js</code> in the <code>inst/htmlwidgets</code> directory so\nthat R knows to include it.</p>\n</li>\n<li>\n<p><code>entryPoints</code> determines the starting point of the bundling process.\nThis can be set to any top-level file that imports other dependencies\nthat calls <code>HTMLWidgets.widget()</code>. packer use the convention of\n<code>srcjs/widgets/&#x3C;widget-name>.js</code> as the entry point.</p>\n</li>\n<li>\n<p><code>externals</code> declares the dependencies that we don’t need webpack to\nresolve. This includes <code>Shiny</code> and <code>HTMLWidgets</code> which is outside of\nthe <code>node_modules</code> folder and added by R. If we don’t declare them\nwebpack will be report an error as it can’t find them.</p>\n</li>\n</ul>\n<p>Besides, there is also a <code>loaders</code> option that tells webpack how to\npreprocess each file type. If we are developing a regular javascript\nwebsite, this will include different preprocessors for javascript, css,\nscss, etc. Though in the context of htmlwidgets it’s all setup by\npacker.</p>\n<p>Now, if we run <code>packer::bundle_dev()</code>, it will invoke\n<code>npm run development</code> specified in the <code>scripts</code> section in\n<code>package.json</code>, which then runs webpack with development configurations.\nwebpack will include all necessary files and bundle them into a\n<code>inst/htmlwidgets</code>. Anytime we make a change to the <code>srcjs</code> directory,\nwe need to run <code>packer::bundle_dev()</code> to update the dist file.</p>\n<p>This time, since our project follows standard javascript project\nstructure with <code>package.json</code> and <code>node_modules</code>. When we are writing\nJavaScript code, our text editor will be able to resolve them and\nprovide intellisense. And we can have arbitrary code structure to to\nbetter organize our code, as long as it is imported by the entry file.</p>\n<h2>Using TypeScript and esbuild</h2>\n<p>packer produces decent boilderplate if you are happy with simple\nJavaScript libraries and webpack. However, if you need to include\nTypeScript, Sass or frameworks like React and Svelte, webpack\nconfigurations can be notoriously time-consuming. Although packer also\nprovides templates for the JavaScript version of React and Vue, but they\nstill require a handful of customization in my opinion. Further, webpack\nis sometimes considered outdated with bigger bundle size and slow\nbundling speed.</p>\n<p>So if you are like me who goes out of his way to have an as “optimized”\npackage as possible, it may be better off to have a personal setup\nsimilar to packer with optimized replacements. In essence it’s just a\nmatter of producing a dist file in the <code>inst/htmlwidgets/</code> directory\nthat guarantees the best development experience, and I will share one\ncombo I find most comfortable. TypeScript is used to replace javascript\nfor static typing, and esbuild to replace webpack with hundreds times\nfaster performance , simpler configurations, and native support for\nTypeScript.</p>\n<p>During my recent development of the\n<a href=\"https://github.com/qiushiyan/xkcd\">xkcd</a> htmlwidgets package, I migrate\na packer-generated setup to one with TypeScript and esbuild.</p>\n<p>The first thing is to remove webpack related dependencies in\n<code>package.json</code> and run <code>yarn update</code>. Then we can install TypeScript,\nesbuild and whatever JavaScript library you want to work with</p>\n<i-code value=\"yarn add -D typescript esbuild @types/node\nyarn add <target-package>\n\" lang=\"bash\"></i-code>\n<p>We can also remove all the webpack configurations in <code>srcjs/config</code> and\n<code>webpack.*.js</code> files in the root directory.</p>\n<p>At this point, our <code>package.json</code> file should look like this</p>\n<i-code value=\"{\n    &#x22;devDependencies&#x22;: {\n        &#x22;@types/node&#x22;: &#x22;^17.0.12&#x22;,\n        &#x22;esbuild&#x22;: &#x22;^0.14.14&#x22;,\n        &#x22;typescript&#x22;: &#x22;^4.5.5&#x22;\n    },\n    &#x22;dependencies&#x22;: {\n        &#x22;chart.xkcd&#x22;: &#x22;^1.1.13&#x22; // here goes all js dependencies\n    }\n}\n\" lang=\"json\" filename=\" package.json\"></i-code>\n<p>Next, let’s create our entry point file, I like to name it <code>index.ts</code>\nunder the <code>srcts</code> directory:</p>\n<i-code value=\"import * as chartXkcd from &#x22;chart.xkcd&#x22;;\n\nHTMLWidgets.widget({\n  name: &#x22;xkcd&#x22;,\n  type: &#x22;output&#x22;,\n  factory: function (el: HTMLElement, width: number, height: number) {\n    // TODO: define shared variables for this instance\n    return {\n      // !callout[/renderValue/] plotting logic\n      renderValue: function (x: any) {\n\n      },\n      // !callout[/resize/] resize logic when screen size changes\n      resize: function (width: number, height: number) {\n\n      },\n    };\n  },\n});\n\" lang=\"typescript\" filename=\" srcts/index.ts\"></i-code>\n<p>Now, let’s configure esbuild to meet the requirments of htmlwidgets.\nSince esbuild does not have a configuration file that will be\nautomatically pick up when invoked from the command line, we’ll create a\nnormal <code>esbuild.js</code> file in the root directory and then run it through\n<code>node</code>.</p>\n<i-code value=\"const esbuild = require(&#x22;esbuild&#x22;);\nconst path = require(&#x22;path&#x22;);\n\nesbuild\n  .build({\n    entryPoints: [path.join(__dirname, &#x22;srcts/index.ts&#x22;)],\n    bundle: true,\n    outfile: path.join(__dirname, &#x22;inst/htmlwidgets/xkcd.js&#x22;),\n    platform: &#x22;node&#x22;,\n    format: &#x22;cjs&#x22;,\n    external: [&#x22;Shiny&#x22;, &#x22;HTMLWidgets&#x22;],\n    watch: {\n      onRebuild(error, result) {\n        if (error) console.error(&#x22;watch build failed:&#x22;, error);\n        else console.log(&#x22;watch build succeeded:&#x22;, result);\n      },\n    },\n  })\n  .catch((err) => {\n    process.stderr.write(err.stderr);\n    process.exit(1);\n  });\n\" lang=\"javascript\" filename=\" esbuild.js\"></i-code>\n<p>Note that esbuild share similar configurations with webpack, we are\nagain declaring entry file (<code>entryPoints</code>), where the bundled file\nshould go (<code>outfile</code>), and external dependencies (<code>external</code>). The last\nstep is adding a command that invokes this script and do the bundling:</p>\n<i-code value=\"{\n  &#x22;scripts&#x22;: {\n        &#x22;watch&#x22;: &#x22;node esbuild.js&#x22;\n    },\n    &#x22;devDependencies&#x22;: {\n        &#x22;@types/node&#x22;: &#x22;^17.0.12&#x22;,\n        &#x22;esbuild&#x22;: &#x22;^0.14.14&#x22;,\n        &#x22;typescript&#x22;: &#x22;^4.5.5&#x22;\n    },\n    &#x22;dependencies&#x22;: {\n        &#x22;chart.xkcd&#x22;: &#x22;^1.1.13&#x22;\n    }\n}\n\" lang=\"json\" filename=\" package.json\"></i-code>\n<p>Now, run <code>yarn watch</code> from the command line to use build script\n<code>esbuild.js</code>, esbuild starts with the message:</p>\n<i-code value=\"yarn watch\n#> yarn run v1.22.17\n#> $ node esbuild.js\n#> watch build succeeded: { errors: [], warnings: [], stop: [Function: stop] }\n\" lang=\"bash\"></i-code>\n<p>This will create the <code>&#x3C;widget-name>.js</code> dist file under\n<code>inst/htmlwidgets/</code>. Because we set <code>watch</code> in <code>esbuild.js</code>, esbuild\nwill watch for changes in the entry file and related modules and rebuild\nthe bundle whenever it changes. This means if we are making only making\na change on the JavaScript side, the widget should update automatically\nnext time it’s created. So there is no similar need to call\n<code>packer::bundle_dev()</code> again.</p>\n<p>With this setup, it’s easy to include any additional libraries you like\nto use. For example, if you want to include\n<a href=\"https://tailwindcss.com/\">tailwindcss</a> in your widget, you can simply\n<code>yarn add</code> tailwind and look up the corresponding tailwind-esbuild\nconfiguration.</p>",
    "slug": "developing-htmlwidgets-in-r-with-typescript-and-esbuild"
  }
]