{
  "hash": "ed419eb91b1d0feeb0669f1a1e3bb43a",
  "result": {
    "markdown": "::: {.cell}\n\n```{.r .cell-code}\n{{data}}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> function (..., list = character(), package = NULL, lib.loc = NULL, \n#>     verbose = getOption(\"verbose\"), envir = .GlobalEnv, overwrite = TRUE) \n#> {\n#>     fileExt <- function(x) {\n#>         db <- grepl(\"\\\\.[^.]+\\\\.(gz|bz2|xz)$\", x)\n#>         ans <- sub(\".*\\\\.\", \"\", x)\n#>         ans[db] <- sub(\".*\\\\.([^.]+\\\\.)(gz|bz2|xz)$\", \"\\\\1\\\\2\", \n#>             x[db])\n#>         ans\n#>     }\n#>     my_read_table <- function(...) {\n#>         lcc <- Sys.getlocale(\"LC_COLLATE\")\n#>         on.exit(Sys.setlocale(\"LC_COLLATE\", lcc))\n#>         Sys.setlocale(\"LC_COLLATE\", \"C\")\n#>         read.table(...)\n#>     }\n#>     stopifnot(is.character(list))\n#>     names <- c(as.character(substitute(list(...))[-1L]), list)\n#>     if (!is.null(package)) {\n#>         if (!is.character(package)) \n#>             stop(\"'package' must be a character vector or NULL\")\n#>     }\n#>     paths <- find.package(package, lib.loc, verbose = verbose)\n#>     if (is.null(lib.loc)) \n#>         paths <- c(path.package(package, TRUE), if (!length(package)) getwd(), \n#>             paths)\n#>     paths <- unique(normalizePath(paths[file.exists(paths)]))\n#>     paths <- paths[dir.exists(file.path(paths, \"data\"))]\n#>     dataExts <- tools:::.make_file_exts(\"data\")\n#>     if (length(names) == 0L) {\n#>         db <- matrix(character(), nrow = 0L, ncol = 4L)\n#>         for (path in paths) {\n#>             entries <- NULL\n#>             packageName <- if (file_test(\"-f\", file.path(path, \n#>                 \"DESCRIPTION\"))) \n#>                 basename(path)\n#>             else \".\"\n#>             if (file_test(\"-f\", INDEX <- file.path(path, \"Meta\", \n#>                 \"data.rds\"))) {\n#>                 entries <- readRDS(INDEX)\n#>             }\n#>             else {\n#>                 dataDir <- file.path(path, \"data\")\n#>                 entries <- tools::list_files_with_type(dataDir, \n#>                   \"data\")\n#>                 if (length(entries)) {\n#>                   entries <- unique(tools::file_path_sans_ext(basename(entries)))\n#>                   entries <- cbind(entries, \"\")\n#>                 }\n#>             }\n#>             if (NROW(entries)) {\n#>                 if (is.matrix(entries) && ncol(entries) == 2L) \n#>                   db <- rbind(db, cbind(packageName, dirname(path), \n#>                     entries))\n#>                 else warning(gettextf(\"data index for package %s is invalid and will be ignored\", \n#>                   sQuote(packageName)), domain = NA, call. = FALSE)\n#>             }\n#>         }\n#>         colnames(db) <- c(\"Package\", \"LibPath\", \"Item\", \"Title\")\n#>         footer <- if (missing(package)) \n#>             paste0(\"Use \", sQuote(paste(\"data(package =\", \".packages(all.available = TRUE))\")), \n#>                 \"\\n\", \"to list the data sets in all *available* packages.\")\n#>         else NULL\n#>         y <- list(title = \"Data sets\", header = NULL, results = db, \n#>             footer = footer)\n#>         class(y) <- \"packageIQR\"\n#>         return(y)\n#>     }\n#>     paths <- file.path(paths, \"data\")\n#>     for (name in names) {\n#>         found <- FALSE\n#>         for (p in paths) {\n#>             tmp_env <- if (overwrite) \n#>                 envir\n#>             else new.env()\n#>             if (file_test(\"-f\", file.path(p, \"Rdata.rds\"))) {\n#>                 rds <- readRDS(file.path(p, \"Rdata.rds\"))\n#>                 if (name %in% names(rds)) {\n#>                   found <- TRUE\n#>                   if (verbose) \n#>                     message(sprintf(\"name=%s:\\t found in Rdata.rds\", \n#>                       name), domain = NA)\n#>                   thispkg <- sub(\".*/([^/]*)/data$\", \"\\\\1\", p)\n#>                   thispkg <- sub(\"_.*$\", \"\", thispkg)\n#>                   thispkg <- paste0(\"package:\", thispkg)\n#>                   objs <- rds[[name]]\n#>                   lazyLoad(file.path(p, \"Rdata\"), envir = tmp_env, \n#>                     filter = function(x) x %in% objs)\n#>                   break\n#>                 }\n#>                 else if (verbose) \n#>                   message(sprintf(\"name=%s:\\t NOT found in names() of Rdata.rds, i.e.,\\n\\t%s\\n\", \n#>                     name, paste(names(rds), collapse = \",\")), \n#>                     domain = NA)\n#>             }\n#>             if (file_test(\"-f\", file.path(p, \"Rdata.zip\"))) {\n#>                 warning(\"zipped data found for package \", sQuote(basename(dirname(p))), \n#>                   \".\\nThat is defunct, so please re-install the package.\", \n#>                   domain = NA)\n#>                 if (file_test(\"-f\", fp <- file.path(p, \"filelist\"))) \n#>                   files <- file.path(p, scan(fp, what = \"\", quiet = TRUE))\n#>                 else {\n#>                   warning(gettextf(\"file 'filelist' is missing for directory %s\", \n#>                     sQuote(p)), domain = NA)\n#>                   next\n#>                 }\n#>             }\n#>             else {\n#>                 files <- list.files(p, full.names = TRUE)\n#>             }\n#>             files <- files[grep(name, files, fixed = TRUE)]\n#>             if (length(files) > 1L) {\n#>                 o <- match(fileExt(files), dataExts, nomatch = 100L)\n#>                 paths0 <- dirname(files)\n#>                 paths0 <- factor(paths0, levels = unique(paths0))\n#>                 files <- files[order(paths0, o)]\n#>             }\n#>             if (length(files)) {\n#>                 for (file in files) {\n#>                   if (verbose) \n#>                     message(\"name=\", name, \":\\t file= ...\", .Platform$file.sep, \n#>                       basename(file), \"::\\t\", appendLF = FALSE, \n#>                       domain = NA)\n#>                   ext <- fileExt(file)\n#>                   if (basename(file) != paste0(name, \".\", ext)) \n#>                     found <- FALSE\n#>                   else {\n#>                     found <- TRUE\n#>                     zfile <- file\n#>                     zipname <- file.path(dirname(file), \"Rdata.zip\")\n#>                     if (file.exists(zipname)) {\n#>                       Rdatadir <- tempfile(\"Rdata\")\n#>                       dir.create(Rdatadir, showWarnings = FALSE)\n#>                       topic <- basename(file)\n#>                       rc <- .External(C_unzip, zipname, topic, \n#>                         Rdatadir, FALSE, TRUE, FALSE, FALSE)\n#>                       if (rc == 0L) \n#>                         zfile <- file.path(Rdatadir, topic)\n#>                     }\n#>                     if (zfile != file) \n#>                       on.exit(unlink(zfile))\n#>                     switch(ext, R = , r = {\n#>                       library(\"utils\")\n#>                       sys.source(zfile, chdir = TRUE, envir = tmp_env)\n#>                     }, RData = , rdata = , rda = load(zfile, \n#>                       envir = tmp_env), TXT = , txt = , tab = , \n#>                       tab.gz = , tab.bz2 = , tab.xz = , txt.gz = , \n#>                       txt.bz2 = , txt.xz = assign(name, my_read_table(zfile, \n#>                         header = TRUE, as.is = FALSE), envir = tmp_env), \n#>                       CSV = , csv = , csv.gz = , csv.bz2 = , \n#>                       csv.xz = assign(name, my_read_table(zfile, \n#>                         header = TRUE, sep = \";\", as.is = FALSE), \n#>                         envir = tmp_env), found <- FALSE)\n#>                   }\n#>                   if (found) \n#>                     break\n#>                 }\n#>                 if (verbose) \n#>                   message(if (!found) \n#>                     \"*NOT* \", \"found\", domain = NA)\n#>             }\n#>             if (found) \n#>                 break\n#>         }\n#>         if (!found) {\n#>             warning(gettextf(\"data set %s not found\", sQuote(name)), \n#>                 domain = NA)\n#>         }\n#>         else if (!overwrite) {\n#>             for (o in ls(envir = tmp_env, all.names = TRUE)) {\n#>                 if (exists(o, envir = envir, inherits = FALSE)) \n#>                   warning(gettextf(\"an object named %s already exists and will not be overwritten\", \n#>                     sQuote(o)))\n#>                 else assign(o, get(o, envir = tmp_env, inherits = FALSE), \n#>                   envir = envir)\n#>             }\n#>             rm(tmp_env)\n#>         }\n#>     }\n#>     invisible(names)\n#> }\n#> <bytecode: 0x111856748>\n#> <environment: namespace:utils>\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}