{
  "hash": "5c8234f804f8f214ef3a0ec995d6b986",
  "result": {
    "markdown": "---\ntitle: Tidy data with pandas\ndate: '2020-05-12'\ncategories: [Python, R]\ndescription: \"Finally some notes on tidying messy data with pandas so I don't have to learn it again\"\nbibliography: ref.bib\nimage: featured.png\nimage-alt: artwork by @allison_hosrt\nfilters:\n  - language-marker\nknitr:\n  opts_chunk:\n      collapse: false\n      comment: \"\"\n---\n\n\nI have been been doing some recap on how to do basic data processing and cleaning in Python with pandas. So this post is mostly a self-reminder on how to deal with messy data in Python, by reproducing examples presented in Hadley Wickham's [Tidy Data](https://vita.had.co.nz/papers/tidy-data.pdf) paper [@JSSv059i10].\n\n## Introduction\n\nThe most significant contribution of this well-known work is that it gave clear definition on what \"tidy\" means for a dataset. There are 3 main requirements, as illustrated on [`tidyr`](https://tidyr.tidyverse.org/)'s website (evolving from what Hadley originally proposed):\n\n1. Every column is a variable.\n2. Every row is an observation.\n3. Every cell is a single value.\n\nMessy data are, by extension, datasets in volation of these 3 rules. The author then described the five most common problems with messy datasets:\n\n- Column headers are values, not variable names.\n- Multiple variables are stored in one column.\n- Variables are stored in both rows and columns.\n- Multiple types of observational units are stored in the same table.\n- A single observational unit is stored in multiple tables.\n\nIn this post I will be focusing on  the first 3 symptoms since the other two violations often occur when working with databases. All datasets come from Hadley's [repo](https://github.com/hadley/tidy-data) containing materials for the paper and [Daniel Chen](https://chendaniely.github.io/)'s 2019 SciPy tutorial on data processing with pandas.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n## Column headers are values, not variable names\n\n\n::: {.cell}\n\n```{.python .cell-code}\npew = pd.read_csv(\"https://github.com/qiushiyan/blog-data/blob/main/pew.csv?raw=true\")\npew.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             religion  <$10k  $10-20k  ...  $100-150k  >150k  Don't know/refused\n0            Agnostic     27       34  ...        109     84                  96\n1             Atheist     12       27  ...         59     74                  76\n2            Buddhist     27       21  ...         39     53                  54\n3            Catholic    418      617  ...        792    633                1489\n4  Don’t know/refused     15       14  ...         17     18                 116\n\n[5 rows x 11 columns]\n```\n:::\n:::\n\n\nThe `pew` dataset explores the relationship between income and religion in the US, produced by the Pew Research Center. To tidy it, we think of its \"right\" form if we are to answer data analysis questions. Say, what if we want to a person's income is influenced by his religion or the other way around. It should be obvious that we need to derive from `pew` a column to indicate the level of a person's income, and another column being count of any combination of income and religion. `pew` is messy in the sense that all column names besides `religion`, from `<$10k` to `Don't know/refused`, should be different levels (values) of a column storing information about income.\n\nThe code to do this is fairly easy in pandas, the `.melt` method is very similar to `tidyr::pivot_longer` and its namesake in the retired `reshape2` package.\n\n::: {.cell}\n\n```{.python .cell-code}\ntidy_pew = pew.melt(id_vars = \"religion\", var_name = \"income\", value_name = \"count\")\ntidy_pew.head(20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   religion   income  count\n0                  Agnostic    <$10k     27\n1                   Atheist    <$10k     12\n2                  Buddhist    <$10k     27\n3                  Catholic    <$10k    418\n4        Don’t know/refused    <$10k     15\n5          Evangelical Prot    <$10k    575\n6                     Hindu    <$10k      1\n7   Historically Black Prot    <$10k    228\n8         Jehovah's Witness    <$10k     20\n9                    Jewish    <$10k     19\n10            Mainline Prot    <$10k    289\n11                   Mormon    <$10k     29\n12                   Muslim    <$10k      6\n13                 Orthodox    <$10k     13\n14          Other Christian    <$10k      9\n15             Other Faiths    <$10k     20\n16    Other World Religions    <$10k      5\n17             Unaffiliated    <$10k    217\n18                 Agnostic  $10-20k     34\n19                  Atheist  $10-20k     27\n```\n:::\n:::\n\n\n\nNow let's calculate the $\\chi^2$ statistic in R and the corresponding p value；\n\n\n\n::: {.cell display-language='true'}\n\n```{.r .cell-code}\nlibrary(infer)\nchisq_stat <- py$tidy_pew |>\n  tidyr::uncount(count) |>\n  specify(religion ~ income) |>\n  hypothesize(null = \"independence\") |>\n  calculate(stat = \"Chisq\")\n\npy$tidy_pew |>\n  tidyr::uncount(count) |>\n  specify(religion ~ income) |>\n  hypothesize(null = \"independence\") |>\n  visualize(method = \"theoretical\") +\n  shade_p_value(obs_stat = chisq_stat, direction = \"right\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=768}\n:::\n:::\n\n\nThis shows strong relationship between `income` and `religion`.\n\nAnother common use of this wide data format is to record regularly spaced observations over time, illustrated by the `billboard` dataset. Ther rank of a specific track in each week after it enters the Billboard top 100 is recorded in 75 columns, `wk1` to `wk75`.\n\n\n::: {.cell display-language='true'}\n\n```{.python .cell-code}\nbillboard = pd.read_csv(\"https://github.com/qiushiyan/blog-data/blob/main/billboard.csv?raw=true\")\nbillboard\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     year            artist                    track  ... wk74 wk75  wk76\n0    2000             2 Pac  Baby Don't Cry (Keep...  ...  NaN  NaN   NaN\n1    2000           2Ge+her  The Hardest Part Of ...  ...  NaN  NaN   NaN\n2    2000      3 Doors Down               Kryptonite  ...  NaN  NaN   NaN\n3    2000      3 Doors Down                    Loser  ...  NaN  NaN   NaN\n4    2000          504 Boyz            Wobble Wobble  ...  NaN  NaN   NaN\n..    ...               ...                      ...  ...  ...  ...   ...\n312  2000       Yankee Grey     Another Nine Minutes  ...  NaN  NaN   NaN\n313  2000  Yearwood, Trisha          Real Live Woman  ...  NaN  NaN   NaN\n314  2000   Ying Yang Twins  Whistle While You Tw...  ...  NaN  NaN   NaN\n315  2000     Zombie Nation            Kernkraft 400  ...  NaN  NaN   NaN\n316  2000   matchbox twenty                     Bent  ...  NaN  NaN   NaN\n\n[317 rows x 81 columns]\n```\n:::\n:::\n\n\nIf we are to answer questions like \"what are the average ranking of artists across all weeks?\", the `wk*` columns need to be transformed into values:  ^[Although both pandas and dplyr (> 1.0) supports row-wise operations, we will suffer some performance penalties for not utilizing vectorization.]\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntidy_billboard = billboard.melt(id_vars = [\"year\", \"artist\", \"track\", \"time\", \"date.entered\"],\n                                var_name = \"week\",\n                                value_name = \"rank\")\n\ntidy_billboard\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       year            artist                    track  ... date.entered  week  rank\n0      2000             2 Pac  Baby Don't Cry (Keep...  ...   2000-02-26   wk1  87.0\n1      2000           2Ge+her  The Hardest Part Of ...  ...   2000-09-02   wk1  91.0\n2      2000      3 Doors Down               Kryptonite  ...   2000-04-08   wk1  81.0\n3      2000      3 Doors Down                    Loser  ...   2000-10-21   wk1  76.0\n4      2000          504 Boyz            Wobble Wobble  ...   2000-04-15   wk1  57.0\n...     ...               ...                      ...  ...          ...   ...   ...\n24087  2000       Yankee Grey     Another Nine Minutes  ...   2000-04-29  wk76   NaN\n24088  2000  Yearwood, Trisha          Real Live Woman  ...   2000-04-01  wk76   NaN\n24089  2000   Ying Yang Twins  Whistle While You Tw...  ...   2000-03-18  wk76   NaN\n24090  2000     Zombie Nation            Kernkraft 400  ...   2000-09-02  wk76   NaN\n24091  2000   matchbox twenty                     Bent  ...   2000-04-29  wk76   NaN\n\n[24092 rows x 7 columns]\n```\n:::\n:::\n\n\nNow we can compute the average ranking:\n\n\n::: {.cell}\n\n```{.python .cell-code}\n(tidy_billboard.\n  groupby(\"artist\")[[\"rank\"]].\n  mean().\n  sort_values(by = \"rank\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                                   rank\nartist                                 \nSantana                       10.500000\nElliott, Missy \"Misdemeanor\"  14.333333\nmatchbox twenty               18.641026\nN'Sync                        18.648649\nJanet                         19.416667\n...                                 ...\nLil' Mo                       98.142857\nLL Cool J                     98.500000\nZombie Nation                 99.000000\nFragma                        99.000000\nSmith, Will                   99.000000\n\n[228 rows x 1 columns]\n```\n:::\n:::\n\n\n## Multiple variables stored in one column\n\nThe `tb` daaset comes from the World Health Organisation, and records the counts of confirmed tuberculosis cases by country, year, and demographic group. The demographic groups are broken down by sex (m, f)  and age (0–14, 15–25, 25–34,  35–44).\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntb = pd.read_csv(\"https://github.com/qiushiyan/blog-data/blob/main/tb.csv?raw=true\")\ntb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    country  year   m014   m1524   m2534  ...   f3544  f4554  f5564   f65  fu\n0        AD  2000    0.0     0.0     1.0  ...     NaN    NaN    NaN   NaN NaN\n1        AE  2000    2.0     4.0     4.0  ...     3.0    0.0    0.0   4.0 NaN\n2        AF  2000   52.0   228.0   183.0  ...   339.0  205.0   99.0  36.0 NaN\n3        AG  2000    0.0     0.0     0.0  ...     0.0    0.0    0.0   0.0 NaN\n4        AL  2000    2.0    19.0    21.0  ...     8.0    8.0    5.0  11.0 NaN\n..      ...   ...    ...     ...     ...  ...     ...    ...    ...   ...  ..\n196      YE  2000  110.0   789.0   689.0  ...   517.0  345.0  247.0  92.0 NaN\n197      YU  2000    NaN     NaN     NaN  ...     NaN    NaN    NaN   NaN NaN\n198      ZA  2000  116.0   723.0  1999.0  ...   933.0  423.0  167.0  80.0 NaN\n199      ZM  2000  349.0  2175.0  2610.0  ...  1305.0  186.0  112.0  75.0 NaN\n200      ZW  2000    NaN     NaN     NaN  ...     NaN    NaN    NaN   NaN NaN\n\n[201 rows x 18 columns]\n```\n:::\n:::\n\n\n\nTo clean this data, we first melt all columns except for `country` and `year` in return for a longer version of `tb`, and then seperate the `variable` column into two pieces of information, `sex` and `age`.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntb_long = tb.melt(id_vars = [\"country\", \"year\"])\nsex = tb_long[\"variable\"].str.split(pat = \"(m|f)(.+)\").str.get(1)\nage = tb_long[\"variable\"].str.split(pat = \"(m|f)(.+)\").str.get(2)\n\nsex.head(), age.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(0    m\n1    m\n2    m\n3    m\n4    m\nName: variable, dtype: object, 0    014\n1    014\n2    014\n3    014\n4    014\nName: variable, dtype: object)\n```\n:::\n:::\n\n\nAdd these two columns and drop the redundant `variable` column\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntidy_tb = (tb_long\n    .assign(sex = sex, age = age)\n    .drop(\"variable\", axis = \"columns\"))\n\ntidy_tb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     country  year  value sex  age\n0         AD  2000    0.0   m  014\n1         AE  2000    2.0   m  014\n2         AF  2000   52.0   m  014\n3         AG  2000    0.0   m  014\n4         AL  2000    2.0   m  014\n...      ...   ...    ...  ..  ...\n3211      YE  2000    NaN   f    u\n3212      YU  2000    NaN   f    u\n3213      ZA  2000    NaN   f    u\n3214      ZM  2000    NaN   f    u\n3215      ZW  2000    NaN   f    u\n\n[3216 rows x 5 columns]\n```\n:::\n:::\n\n\n## Variables are stored in both rows and columns\n\n> The `weather` data shows daily weather data from the Global Historical Climatology Network for one  weather station (MX17004) in Mexico for five months in 2010.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nweather = pd.read_csv(\"https://github.com/qiushiyan/blog-data/blob/main/weather.csv?raw=true\")\nweather\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         id  year  month element    d1  ...   d27   d28   d29   d30   d31\n0   MX17004  2010      1    tmax   NaN  ...   NaN   NaN   NaN  27.8   NaN\n1   MX17004  2010      1    tmin   NaN  ...   NaN   NaN   NaN  14.5   NaN\n2   MX17004  2010      2    tmax   NaN  ...   NaN   NaN   NaN   NaN   NaN\n3   MX17004  2010      2    tmin   NaN  ...   NaN   NaN   NaN   NaN   NaN\n4   MX17004  2010      3    tmax   NaN  ...   NaN   NaN   NaN   NaN   NaN\n5   MX17004  2010      3    tmin   NaN  ...   NaN   NaN   NaN   NaN   NaN\n6   MX17004  2010      4    tmax   NaN  ...  36.3   NaN   NaN   NaN   NaN\n7   MX17004  2010      4    tmin   NaN  ...  16.7   NaN   NaN   NaN   NaN\n8   MX17004  2010      5    tmax   NaN  ...  33.2   NaN   NaN   NaN   NaN\n9   MX17004  2010      5    tmin   NaN  ...  18.2   NaN   NaN   NaN   NaN\n10  MX17004  2010      6    tmax   NaN  ...   NaN   NaN  30.1   NaN   NaN\n11  MX17004  2010      6    tmin   NaN  ...   NaN   NaN  18.0   NaN   NaN\n12  MX17004  2010      7    tmax   NaN  ...   NaN   NaN   NaN   NaN   NaN\n13  MX17004  2010      7    tmin   NaN  ...   NaN   NaN   NaN   NaN   NaN\n14  MX17004  2010      8    tmax   NaN  ...   NaN   NaN  28.0   NaN  25.4\n15  MX17004  2010      8    tmin   NaN  ...   NaN   NaN  15.3   NaN  15.4\n16  MX17004  2010     10    tmax   NaN  ...   NaN  31.2   NaN   NaN   NaN\n17  MX17004  2010     10    tmin   NaN  ...   NaN  15.0   NaN   NaN   NaN\n18  MX17004  2010     11    tmax   NaN  ...  27.7   NaN   NaN   NaN   NaN\n19  MX17004  2010     11    tmin   NaN  ...  14.2   NaN   NaN   NaN   NaN\n20  MX17004  2010     12    tmax  29.9  ...   NaN   NaN   NaN   NaN   NaN\n21  MX17004  2010     12    tmin  13.8  ...   NaN   NaN   NaN   NaN   NaN\n\n[22 rows x 35 columns]\n```\n:::\n:::\n\n\nThere are two major problems with `weather`:\n\n- `d1`, `d2`, ..., `d31` should be values instead of column names (solved by `.melt`)\n- On the other hand, values in the `element` column should be names, it should be spread into two columns named `tmax`, `tmin` (solved by `.pivot_table`)\n\n\n::: {.cell}\n\n```{.python .cell-code}\n(weather.\n  melt(id_vars = [\"id\", \"year\", \"month\", \"element\"], var_name = \"day\", value_name = \"temp\").\n  pivot_table(index = [\"id\", \"year\", \"month\", \"day\"],\n              columns = \"element\",\n              values = \"temp\").\n  reset_index().\n  head()\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nelement       id  year  month  day  tmax  tmin\n0        MX17004  2010      1  d30  27.8  14.5\n1        MX17004  2010      2  d11  29.7  13.4\n2        MX17004  2010      2   d2  27.3  14.4\n3        MX17004  2010      2  d23  29.9  10.7\n4        MX17004  2010      2   d3  24.1  14.4\n```\n:::\n:::\n\n\n\n## Case study: mortality data from Mexico\n\nAfter stating these common problems and their remidies, Hadley presented a case study section on how tidy dataset can facilitate data analysis. The case study uses individual-level mortality data from Mexico.  The goal is to find causes of death with unusual temporal patterns, at hour level. It's time to move back from Python to R!\n\n\n::: {.cell display-language='true'}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\n\ndeaths <- readr::read_csv(\"https://github.com/qiushiyan/blog-data/blob/main/mexico-deaths.csv?raw=true\") |> na.omit()\ndeaths\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 513,273 × 5\n     yod   mod   dod   hod cod  \n   <dbl> <dbl> <dbl> <dbl> <chr>\n 1  1920    11    17     3 W78  \n 2  1923     2     4    16 J44  \n 3  1923     6    23    19 E12  \n 4  1926     2     5    16 C67  \n 5  1926     4     1    16 J44  \n 6  1928    10    30    19 I27  \n 7  1929     4    23    15 I25  \n 8  1930     9    11    19 E14  \n 9  1930    12    22    19 E11  \n10  1931     5    26    11 K65  \n# … with 513,263 more rows\n```\n:::\n:::\n\n\nThe columns are year, month, day, hour and cause of specific death respectively. Another table `codes` explains what acronyms in `cod` mean.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncodes <- readr::read_csv(\"https://github.com/qiushiyan/blog-data/blob/main/codes.csv?raw=true\")\ncodes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,851 × 2\n   cod   disease                                                              \n   <chr> <chr>                                                                \n 1 A00   \"Cholera\"                                                            \n 2 A01   \"Typhoid and paratyphoid\\nfevers\"                                    \n 3 A02   \"Other salmonella infections\"                                        \n 4 A03   \"Shigellosis\"                                                        \n 5 A04   \"Other bacterial intestinal\\ninfections\"                             \n 6 A05   \"Other bacterial foodborne\\nintoxications, not elsewhere\\nclassified\"\n 7 A06   \"Amebiasis\"                                                          \n 8 A07   \"Other protozoal intestinal\\ndiseases\"                               \n 9 A08   \"Viral and other specified\\nintestinal infections\"                   \n10 A09   \"Diarrhea and gastroenteritis\\nof infectious origin\"                 \n# … with 1,841 more rows\n```\n:::\n:::\n\n\nThanks to the [`reticulate`](https://rstudio.github.io/reticulate/) package, we can mix R and Python code seamlessly. Here is a line plot made with `seaborn` demonstrating total deaths per hour:\n\n\n\n::: {.cell display-language='true'}\n\n```{.python .cell-code}\ndeaths = r.deaths\ndeaths_per_hour = deaths[\"hod\"].value_counts()\nsns.lineplot(x = deaths_per_hour.index, y = deaths_per_hour.values)\nplt.title(\"Temporal pattern of all causes of death\")\nplt.xlabel(\"Hour of the day\")\nplt.ylabel(\"Number of deaths\")\nplt.show()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=768}\n:::\n:::\n\n\nTo provide informative labels for causes, we next join the dataset to the `codes` dataset, on the `cod` variable.\n\n\n\n::: {.cell display-language='true'}\n\n```{.r .cell-code}\ndeaths <- left_join(deaths, codes) |>\n  rename(cause = disease)\n\ndeaths\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 513,273 × 6\n     yod   mod   dod   hod cod   cause                                         \n   <dbl> <dbl> <dbl> <dbl> <chr> <chr>                                         \n 1  1920    11    17     3 W78   \"Inhalation of gastric\\ncontents\"             \n 2  1923     2     4    16 J44   \"Other chronic obstructive\\npulmonary disease\"\n 3  1923     6    23    19 E12   \"Malnutrition-related diabetes\\nmellitus\"     \n 4  1926     2     5    16 C67   \"Malignant neoplasm of bladder\"               \n 5  1926     4     1    16 J44   \"Other chronic obstructive\\npulmonary disease\"\n 6  1928    10    30    19 I27   \"Other pulmonary heart\\ndiseases\"             \n 7  1929     4    23    15 I25   \"Chronic ischemic heart\\ndisease\"             \n 8  1930     9    11    19 E14   \"Unspecified diabetes mellitus\"               \n 9  1930    12    22    19 E11   \"Non-insulin-dependent\\ndiabetes mellitus\"    \n10  1931     5    26    11 K65   \"Peritonitis\"                                 \n# … with 513,263 more rows\n```\n:::\n:::\n\n\n\nThe total deaths for each cause varies over several orders of magnitude: there are 46,794 deaths from heart attack but only 1 from Tularemia.\n\n::: {.cell display-language='true'}\n\n```{.python .cell-code}\n(deaths.groupby([\"cod\"]).\n  size().\n  reset_index(name = \"per_cause\").\n  sort_values(by = \"per_cause\", ascending = False)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      cod  per_cause\n417   I21      46794\n260   E11      42421\n262   E14      27330\n495   J44      16043\n566   K70      12860\n...   ...        ...\n1079  X24          1\n521   K02          1\n939   V30          1\n940   V33          1\n182   D04          1\n\n[1194 rows x 2 columns]\n```\n:::\n:::\n\n\nThis means that rather than the total number, it makes more sense to think in proportions. If a cause of death departs from the overall temporal pattern, then its proportion of deaths in a given hour compared to the total deaths of that cause should differ significantly from that of the hourly deaths at the same time compared to total deaths. I denote these two proportions as `prop1` and `prop2` respectively. To ensure that the causes we consider are sufficiently representative we’ll only work with causes with more than 50 total deaths.\n\n\n::: {.cell display-language='true'}\n\n```{.r .cell-code}\nprop1 <- deaths |>\n  count(hod, cause, name = \"per_hour_per_cause\") |>\n  add_count(cause, wt = per_hour_per_cause, name = \"per_cause\") |>\n  mutate(prop1 = per_hour_per_cause / per_cause)\n\nprop2 <- deaths |>\n  count(hod, name = \"per_hour\") |>\n  add_count(wt = per_hour, name = \"total\") |>\n  mutate(prop2 = per_hour / total)\n```\n:::\n\n\nHadley used mean square error between the two proportions as a kind of distance, to indicate the average degree of anomaly of a cause, and I follow:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndist <- prop1 |>\n  filter(per_cause > 50) |>\n  left_join(prop2, by = \"hod\") |>\n  select(\n    hour = hod,\n    cause,\n    n = per_cause,\n    prop1,\n    prop2\n  ) |>\n  group_by(cause, n) |>\n  summarize(dist = mean((prop1 - prop2)^2)) |>\n  ungroup()\n\ndist |>\n  arrange(desc(dist))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 447 × 3\n   cause                                                               n    dist\n   <chr>                                                           <int>   <dbl>\n 1 \"Accident to powered aircraft\\ncausing injury to occupant\"         57 0.00573\n 2 \"Victim of lightning\"                                              97 0.00513\n 3 \"Bus occupant injured in other\\nand unspecified transport\\nacc…    52 0.00419\n 4 \"Assault (homicide) by smoke,\\nfire, and flames\"                   51 0.00229\n 5 \"Exposure to electric\\ntransmission lines\"                         77 0.00161\n 6 \"Sudden infant death syndrome\"                                    323 0.00156\n 7 \"Drowning and submersion while\\nin natural water\"                 469 0.00133\n 8 \"Motorcycle rider injured in\\ncollision with car, pickup\\ntruc…    66 0.00126\n 9 \"Contact with hornets, wasps,\\nand bees\"                           86 0.00118\n10 \"Exposure to smoke, fire, and\\nflames, undetermined intent\"        51 0.00110\n# … with 437 more rows\n```\n:::\n:::\n\n\nHere we see causes of death with highest `dist` are mainly accidents and rare diseases. However, there is a negative correlation between the frequency of a cause and its deviation, as shown in the following plot, so that the result based solely on the `dist` column would be biased in favour of rare causes.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndist |>\n  ggplot(aes(n, dist)) +\n  geom_jitter() +\n  ggrepel::geom_text_repel(\n    aes(label = cause),\n    top_n(dist, 10)\n  ) +\n  scale_x_log10() +\n  scale_y_log10() +\n  geom_smooth(method = \"lm\") +\n  labs(\n    title = \"Temporal deviation of causes of deaths in Mexico\",\n    y = NULL,\n    x = \"total death\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-1.png){width=960}\n:::\n:::\n\n\n\nThus, our final solution is to build a model with `n` as predictor, and `dist` as response. The cause with highest residual are assumed to have the most deviation. Since the linear trend fits the data quite well, I opt for linear regression (Hadley used robust linear model in the paper).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(broom)\nlm_fit <- lm(log(dist) ~ log(n), data = dist)\ntidy(lm_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 5\n  term        estimate std.error statistic   p.value\n  <chr>          <dbl>     <dbl>     <dbl>     <dbl>\n1 (Intercept)   -3.74     0.110      -34.0 8.34e-126\n2 log(n)        -0.869    0.0186     -46.8 7.55e-174\n```\n:::\n:::\n\n\nLet's plot these residuals against the predictor `log(n)`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\naugment(lm_fit) |>\n  ggplot(aes(`log(n)`, .std.resid)) +\n  geom_hline(yintercept = 0, color = \"red\") +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-1.png){width=768}\n:::\n:::\n\n\n\n> The plot shows an empty region around a standardized residual of 1.5.  So somewhat arbitrarily, we’ll select those diseases with a residual greater than 1.5\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrows <- augment(lm_fit) |>\n  mutate(row = row_number()) |>\n  filter(.std.resid > 1.5) |>\n  select(row) |>\n  pull(row)\n\n\nunusual <- dist |>\n  mutate(row = row_number()) |>\n  filter(row %in% rows) |>\n  select(cause, n)\n\nunusual\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 26 × 2\n   cause                                                                     n\n   <chr>                                                                 <int>\n 1 \"Accident to powered aircraft\\ncausing injury to occupant\"               57\n 2 \"Acute bronchitis\"                                                      684\n 3 \"Acute myocardial infarction\"                                         46794\n 4 \"Assault (homicide) by other\\nand unspecified firearm\\ndischarge\"      7228\n 5 \"Assault (homicide) by sharp\\nobject\"                                  1575\n 6 \"Assault (homicide) by smoke,\\nfire, and flames\"                         51\n 7 \"Bus occupant injured in other\\nand unspecified transport\\naccidents\"    52\n 8 \"Car occupant injured in\\nnoncollision transport\\naccident\"             616\n 9 \"Car occupant injured in other\\nand unspecified transport\\naccidents\"  1938\n10 \"Contact with hornets, wasps,\\nand bees\"                                 86\n# … with 16 more rows\n```\n:::\n:::\n\n\nFinally, we plot the temporal course for each unusual cause of death.\n\n\n::: {.cell .column-screen-inset-shaded}\n\n```{.r .cell-code}\nprop1 |>\n  filter(cause %in% unusual$cause) |>\n  left_join(prop2, by = \"hod\") |>\n  pivot_longer(c(prop1, prop2)) |>\n  ggplot(aes(hod, value, color = name)) +\n  geom_line() +\n  scale_color_manual(\n    name = NULL,\n    labels = c(\"cause-specific\", \"overall\"),\n    values = c(\"#FFBF0F\", \"#0382E5\")\n  ) +\n  facet_wrap(~cause, scales = \"free_y\", labeller = label_wrap_gen(20)) +\n  labs(\n    x = \"hour\", y = NULL, title = \"Most deviated causes of death\",\n    subtitle = \"comparing cause-specific temporal pattern to overall trend\"\n  ) +\n  theme_minimal(base_size = 16) +\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-1.png){width=1920}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}