{
  "hash": "8c0496641bd10c56d2c44ed4b1db92ba",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: A Taste of dplyr 1.0.0\ndate: '2020-06-02'\ndescription:\n    A quick summary of some exciting features coming in dplyr 1.0, e.g. `across()`, row-wise operations and context-dependent expressions\n---\n\n\n\nThis post uses the penguins dataset [@10.1371/journal.pone.0090081] for most demonstration purposes, modified by [Allison Horst](https://github.com/allisonhorst/penguins) (as an alternative to `iris`).\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n#> \n#> Attaching package: 'dplyr'\n#> The following objects are masked from 'package:stats':\n#> \n#>     filter, lag\n#> The following objects are masked from 'package:base':\n#> \n#>     intersect, setdiff, setequal, union\nlibrary(ggplot2)\n\npackageVersion(\"dplyr\")\n#> [1] '1.1.2'\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins <- palmerpenguins::penguins\npenguins\n#> # A tibble: 344 × 8\n#>    species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n#>    <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n#>  1 Adelie  Torgersen           39.1          18.7               181        3750\n#>  2 Adelie  Torgersen           39.5          17.4               186        3800\n#>  3 Adelie  Torgersen           40.3          18                 195        3250\n#>  4 Adelie  Torgersen           NA            NA                  NA          NA\n#>  5 Adelie  Torgersen           36.7          19.3               193        3450\n#>  6 Adelie  Torgersen           39.3          20.6               190        3650\n#>  7 Adelie  Torgersen           38.9          17.8               181        3625\n#>  8 Adelie  Torgersen           39.2          19.6               195        4675\n#>  9 Adelie  Torgersen           34.1          18.1               193        3475\n#> 10 Adelie  Torgersen           42            20.2               190        4250\n#> # ℹ 334 more rows\n#> # ℹ 2 more variables: sex <fct>, year <int>\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>%\n  ggplot(aes(bill_length_mm, bill_depth_mm, color = species, shape = species)) +\n  geom_point()\n#> Warning: Removed 2 rows containing missing values or values outside the scale range\n#> (`geom_point()`).\n#> Warning in vp$just: partial match of 'just' to 'justification'\n```\n\n::: {.cell-output-display}\n![](index_files/figure-commonmark/unnamed-chunk-4-1.png)\n:::\n:::\n\n\n\n## Working within columns\n\nThe new `across()` function supersedes functionalities of `_at`, `_if`, `_all` variants. The first argument, `.cols`, selects the columns you want to operate on. It uses tidy selection (like `select()`) so you can pick variables by position, name, and type. The second argument, `.fns`, is a function or list of functions to apply to each column. This can also be a purrr style formula\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_grouped <- penguins %>% group_by(species)\n\npenguins_grouped %>%\n  summarize(across(starts_with(\"bill\"), mean, na.rm = TRUE),\n    n = n()\n  )\n#> Warning: There was 1 warning in `summarize()`.\n#> ℹ In argument: `across(starts_with(\"bill\"), mean, na.rm = TRUE)`.\n#> ℹ In group 1: `species = Adelie`.\n#> Caused by warning:\n#> ! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\n#> Supply arguments directly to `.fns` through an anonymous function instead.\n#> \n#>   # Previously\n#>   across(a:b, mean, na.rm = TRUE)\n#> \n#>   # Now\n#>   across(a:b, \\(x) mean(x, na.rm = TRUE))\n#> # A tibble: 3 × 4\n#>   species   bill_length_mm bill_depth_mm     n\n#>   <fct>              <dbl>         <dbl> <int>\n#> 1 Adelie              38.8          18.3   152\n#> 2 Chinstrap           48.8          18.4    68\n#> 3 Gentoo              47.5          15.0   124\n```\n:::\n\n\n\n\nFor conditional selection (previous `_if` variants), predicate function should be wrapped in `where`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# double all numeric columns\npenguins %>%\n  mutate(across(where(is.numeric), ~ .x * 2))\n#> # A tibble: 344 × 8\n#>    species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n#>    <fct>   <fct>              <dbl>         <dbl>             <dbl>       <dbl>\n#>  1 Adelie  Torgersen           78.2          37.4               362        7500\n#>  2 Adelie  Torgersen           79            34.8               372        7600\n#>  3 Adelie  Torgersen           80.6          36                 390        6500\n#>  4 Adelie  Torgersen           NA            NA                  NA          NA\n#>  5 Adelie  Torgersen           73.4          38.6               386        6900\n#>  6 Adelie  Torgersen           78.6          41.2               380        7300\n#>  7 Adelie  Torgersen           77.8          35.6               362        7250\n#>  8 Adelie  Torgersen           78.4          39.2               390        9350\n#>  9 Adelie  Torgersen           68.2          36.2               386        6950\n#> 10 Adelie  Torgersen           84            40.4               380        8500\n#> # ℹ 334 more rows\n#> # ℹ 2 more variables: sex <fct>, year <dbl>\n\n# count unique values of all character columns\npenguins %>%\n  summarize(across(where(is.character), ~ length(unique(.x))))\n#> # A tibble: 1 × 0\n```\n:::\n\n\n\n\nApply multiple functions using list and use the `.names` argument to control column names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_grouped %>%\n  summarize(across(matches(\"mm\"),\n    list(\n      min = ~ min(.x, na.rm = TRUE),\n      max = ~ max(.x, na.rm = TRUE)\n    ),\n    .names = \"{fn}_{col}\"\n  ))\n#> # A tibble: 3 × 7\n#>   species   min_bill_length_mm max_bill_length_mm min_bill_depth_mm\n#>   <fct>                  <dbl>              <dbl>             <dbl>\n#> 1 Adelie                  32.1               46                15.5\n#> 2 Chinstrap               40.9               58                16.4\n#> 3 Gentoo                  40.9               59.6              13.1\n#> # ℹ 3 more variables: max_bill_depth_mm <dbl>, min_flipper_length_mm <int>,\n#> #   max_flipper_length_mm <int>\n```\n:::\n\n\n\n\n\n\n\n## Working within rows\n\n\nRow-wise operations require a special type of grouping where each group consists of a single row. You create this with `rowwise()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(\n  student_id = 1:4,\n  test1 = 10:13,\n  test2 = 20:23,\n  test3 = 30:33,\n  test4 = 40:43\n)\ndf %>% rowwise()\n#> # A tibble: 4 × 5\n#> # Rowwise: \n#>   student_id test1 test2 test3 test4\n#>        <int> <int> <int> <int> <int>\n#> 1          1    10    20    30    40\n#> 2          2    11    21    31    41\n#> 3          3    12    22    32    42\n#> 4          4    13    23    33    43\n```\n:::\n\n\n\n`rowwise` doesn’t need any additional arguments unless you have variables that identify the rows,  like `student_id`  here. This can be helpful when you want to keep a row identifier.\n\nLike `group_by`, `rowwise` doesn’t really do anything itself; it just changes how the other verbs work.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% mutate(avg = mean(c(test1, test2, test3, test4)))\n#> # A tibble: 4 × 6\n#>   student_id test1 test2 test3 test4   avg\n#>        <int> <int> <int> <int> <int> <dbl>\n#> 1          1    10    20    30    40  26.5\n#> 2          2    11    21    31    41  26.5\n#> 3          3    12    22    32    42  26.5\n#> 4          4    13    23    33    43  26.5\n\ndf %>%\n  rowwise() %>%\n  mutate(avg = mean(c(test1, test2, test3, test4)))\n#> # A tibble: 4 × 6\n#> # Rowwise: \n#>   student_id test1 test2 test3 test4   avg\n#>        <int> <int> <int> <int> <int> <dbl>\n#> 1          1    10    20    30    40    25\n#> 2          2    11    21    31    41    26\n#> 3          3    12    22    32    42    27\n#> 4          4    13    23    33    43    28\n```\n:::\n\n\n\nIn its essence, `rowwise` vectorize / parallelize a function to acheive rowwisee computation. And in this case, the `mean()` function is vectorized. If there are alternative ways of computing row-wise summaries that take advantage of built-in vectorisation then we do not need `rowwise` at all.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% mutate(s = test1 + test2 + test3)\n#> # A tibble: 4 × 6\n#>   student_id test1 test2 test3 test4     s\n#>        <int> <int> <int> <int> <int> <int>\n#> 1          1    10    20    30    40    60\n#> 2          2    11    21    31    41    63\n#> 3          3    12    22    32    42    66\n#> 4          4    13    23    33    43    69\n\ndf %>%\n  rowwise() %>%\n  mutate(s = test1 + test2 + test3)\n#> # A tibble: 4 × 6\n#> # Rowwise: \n#>   student_id test1 test2 test3 test4     s\n#>        <int> <int> <int> <int> <int> <int>\n#> 1          1    10    20    30    40    60\n#> 2          2    11    21    31    41    63\n#> 3          3    12    22    32    42    66\n#> 4          4    13    23    33    43    69\n```\n:::\n\n\n\nAnother family of summary functions have “parallel” extensions where you can provide multiple variables in the arguments:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  mutate(\n    min = pmin(test1, test2, test3, test4),\n    max = pmax(test1, test2, test3, test4),\n    string = paste(test1, test2, test3, test4, sep = \"-\")\n  )\n#> # A tibble: 4 × 8\n#>   student_id test1 test2 test3 test4   min   max string     \n#>        <int> <int> <int> <int> <int> <int> <int> <chr>      \n#> 1          1    10    20    30    40    10    40 10-20-30-40\n#> 2          2    11    21    31    41    11    41 11-21-31-41\n#> 3          3    12    22    32    42    12    42 12-22-32-42\n#> 4          4    13    23    33    43    13    43 13-23-33-43\n```\n:::\n\n\nWhere these functions exist, they’ll usually be faster than `rowwise`. The advantage of `rowwise` is that it works with any function, not just those that are already vectorised.\n\nHowever, an advantage of `rowwise` even there is other ways is that it’s paired with `c_across()`, which works like `c()` but uses the same tidyselect syntax as `across()`. That makes it easy to operate on multiple variables:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  rowwise() %>%\n  mutate(\n    min = min(c_across(starts_with(\"test\"))),\n    max = max(c_across(starts_with(\"test\")))\n  )\n#> # A tibble: 4 × 7\n#> # Rowwise: \n#>   student_id test1 test2 test3 test4   min   max\n#>        <int> <int> <int> <int> <int> <int> <int>\n#> 1          1    10    20    30    40    10    40\n#> 2          2    11    21    31    41    11    41\n#> 3          3    12    22    32    42    12    42\n#> 4          4    13    23    33    43    13    43\n```\n:::\n\n\n\nPlus, a rowwise df will naturally contain exactly the same rows after `summarize()`, the same as `mutate`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  rowwise() %>%\n  summarize(across(starts_with(\"test\"), ~.x, .names = \"{col}_same\"))\n#> # A tibble: 4 × 4\n#>   test1_same test2_same test3_same test4_same\n#>        <int>      <int>      <int>      <int>\n#> 1         10         20         30         40\n#> 2         11         21         31         41\n#> 3         12         22         32         42\n#> 4         13         23         33         43\n```\n:::\n\n\n\n\n\n### List-columns\n\nBecause lists can contain anything, you can use list-columns to keep related objects together, regardless of what type of thing they are. List-columns give you a convenient storage mechanism and `rowwise` gives you a convenient computation mechanism.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(\n  x = list(1, 2:3, 4:6),\n  y = list(TRUE, 1, \"a\"),\n  z = list(sum, mean, sd)\n)\ndf\n#> # A tibble: 3 × 3\n#>   x         y         z     \n#>   <list>    <list>    <list>\n#> 1 <dbl [1]> <lgl [1]> <fn>  \n#> 2 <int [2]> <dbl [1]> <fn>  \n#> 3 <int [3]> <chr [1]> <fn>\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  rowwise() %>%\n  summarize(\n    x_length = length(x),\n    y_type = typeof(y),\n    z_call = z(1:5)\n  )\n#> # A tibble: 3 × 3\n#>   x_length y_type    z_call\n#>      <int> <chr>      <dbl>\n#> 1        1 logical    15   \n#> 2        2 double      3   \n#> 3        3 character   1.58\n```\n:::\n\n\n\n\n### Simulaiton\n\nThe basic idea of using `rowwise` to perform simulation is to store all your simulation paramters in a data frame, similar to `purrr::pmap`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tribble(\n  ~id, ~n, ~min, ~max,\n  1, 3, 0, 1,\n  2, 2, 10, 100,\n  3, 2, 100, 1000,\n)\n```\n:::\n\n\n\nThen you can either generate a list-column containing the simulated values with `mutate`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  rowwise() %>%\n  mutate(sim = list(runif(n, min, max)))\n#> # A tibble: 3 × 5\n#> # Rowwise: \n#>      id     n   min   max sim      \n#>   <dbl> <dbl> <dbl> <dbl> <list>   \n#> 1     1     3     0     1 <dbl [3]>\n#> 2     2     2    10   100 <dbl [2]>\n#> 3     3     2   100  1000 <dbl [2]>\n```\n:::\n\n\nOr taking advantage of `summarize`'s new features to return multiple rows per group\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  rowwise(everything()) %>%\n  summarize(sim = runif(n, min, max))\n#> Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\n#> dplyr 1.1.0.\n#> ℹ Please use `reframe()` instead.\n#> ℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n#>   always returns an ungrouped data frame and adjust accordingly.\n#> `summarise()` has grouped output by 'id', 'n', 'min', 'max'. You can override\n#> using the `.groups` argument.\n#> # A tibble: 7 × 5\n#> # Groups:   id, n, min, max [3]\n#>      id     n   min   max     sim\n#>   <dbl> <dbl> <dbl> <dbl>   <dbl>\n#> 1     1     3     0     1   0.702\n#> 2     1     3     0     1   0.801\n#> 3     1     3     0     1   0.457\n#> 4     2     2    10   100  44.7  \n#> 5     2     2    10   100  18.3  \n#> 6     3     2   100  1000 930.   \n#> 7     3     2   100  1000 723.\n```\n:::\n\n\n\nThe previous approach\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  mutate(sim = purrr::pmap(., ~ runif(..2, ..3, ..4)))\n#> # A tibble: 3 × 5\n#>      id     n   min   max sim      \n#>   <dbl> <dbl> <dbl> <dbl> <list>   \n#> 1     1     3     0     1 <dbl [3]>\n#> 2     2     2    10   100 <dbl [2]>\n#> 3     3     2   100  1000 <dbl [2]>\n```\n:::\n\n\n\n\n\n## Group-wise models\n\nThe new `nest_by()` function works similarly to `group_nest()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nby_species <- penguins %>% nest_by(species)\nby_species\n#> # A tibble: 3 × 2\n#> # Rowwise:  species\n#>   species                 data\n#>   <fct>     <list<tibble[,7]>>\n#> 1 Adelie             [152 × 7]\n#> 2 Chinstrap           [68 × 7]\n#> 3 Gentoo             [124 × 7]\n```\n:::\n\n\nNow we can use `mutate` to fit a model to each data frame:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nby_species <- by_species %>%\n  rowwise(species) %>%\n  mutate(model = list(lm(bill_length_mm ~ bill_depth_mm, data = data)))\n\nby_species\n#> # A tibble: 3 × 3\n#> # Rowwise:  species\n#>   species                 data model \n#>   <fct>     <list<tibble[,7]>> <list>\n#> 1 Adelie             [152 × 7] <lm>  \n#> 2 Chinstrap           [68 × 7] <lm>  \n#> 3 Gentoo             [124 × 7] <lm>\n```\n:::\n\n\nAnd then extract model summaries or coefficients with `summarize()` and `broom` functions (note that `by_species` is still a rowwise data frame):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nby_species %>%\n  summarize(broom::glance(model))\n#> `summarise()` has grouped output by 'species'. You can override using the\n#> `.groups` argument.\n#> # A tibble: 3 × 13\n#> # Groups:   species [3]\n#>   species   r.squared adj.r.squared sigma statistic  p.value    df logLik   AIC\n#>   <fct>         <dbl>         <dbl> <dbl>     <dbl>    <dbl> <dbl>  <dbl> <dbl>\n#> 1 Adelie        0.153         0.148  2.46      27.0 6.67e- 7     1  -349.  704.\n#> 2 Chinstrap     0.427         0.418  2.55      49.2 1.53e- 9     1  -159.  324.\n#> 3 Gentoo        0.414         0.409  2.37      85.5 1.02e-15     1  -280.  565.\n#> # ℹ 4 more variables: BIC <dbl>, deviance <dbl>, df.residual <int>, nobs <int>\n\nby_species %>%\n  summarize(broom::tidy(model))\n#> Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\n#> dplyr 1.1.0.\n#> ℹ Please use `reframe()` instead.\n#> ℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n#>   always returns an ungrouped data frame and adjust accordingly.\n#> `summarise()` has grouped output by 'species'. You can override using the\n#> `.groups` argument.\n#> # A tibble: 6 × 6\n#> # Groups:   species [3]\n#>   species   term          estimate std.error statistic  p.value\n#>   <fct>     <chr>            <dbl>     <dbl>     <dbl>    <dbl>\n#> 1 Adelie    (Intercept)     23.1       3.03       7.60 3.01e-12\n#> 2 Adelie    bill_depth_mm    0.857     0.165      5.19 6.67e- 7\n#> 3 Chinstrap (Intercept)     13.4       5.06       2.66 9.92e- 3\n#> 4 Chinstrap bill_depth_mm    1.92      0.274      7.01 1.53e- 9\n#> 5 Gentoo    (Intercept)     17.2       3.28       5.25 6.60e- 7\n#> 6 Gentoo    bill_depth_mm    2.02      0.219      9.24 1.02e-15\n```\n:::\n\n\n\nAn alternative approach\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>%\n  group_by(species) %>%\n  group_modify(~ broom::tidy(lm(bill_length_mm ~ bill_depth_mm, data = .x)))\n#> # A tibble: 6 × 6\n#> # Groups:   species [3]\n#>   species   term          estimate std.error statistic  p.value\n#>   <fct>     <chr>            <dbl>     <dbl>     <dbl>    <dbl>\n#> 1 Adelie    (Intercept)     23.1       3.03       7.60 3.01e-12\n#> 2 Adelie    bill_depth_mm    0.857     0.165      5.19 6.67e- 7\n#> 3 Chinstrap (Intercept)     13.4       5.06       2.66 9.92e- 3\n#> 4 Chinstrap bill_depth_mm    1.92      0.274      7.01 1.53e- 9\n#> 5 Gentoo    (Intercept)     17.2       3.28       5.25 6.60e- 7\n#> 6 Gentoo    bill_depth_mm    2.02      0.219      9.24 1.02e-15\n```\n:::\n\n\n\n\n\n## New `summarize` features\n\n### Multiple rows and columns\n\nTwo big changes make `summarize()` much more flexible. A single summary expression can now return:\n\n- A vector of any length, creating multiple rows. (so we can use summary that returns multiple values without `list`)\n\n- A data frame, creating multiple columns.\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_grouped %>%\n  summarize(\n    bill_length_dist = quantile(bill_length_mm,\n      c(0.25, 0.5, 0.75),\n      na.rm = TRUE\n    ),\n    q = c(0.25, 0.5, 0.75)\n  )\n#> Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\n#> dplyr 1.1.0.\n#> ℹ Please use `reframe()` instead.\n#> ℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n#>   always returns an ungrouped data frame and adjust accordingly.\n#> `summarise()` has grouped output by 'species'. You can override using the\n#> `.groups` argument.\n#> # A tibble: 9 × 3\n#> # Groups:   species [3]\n#>   species   bill_length_dist     q\n#>   <fct>                <dbl> <dbl>\n#> 1 Adelie                36.8  0.25\n#> 2 Adelie                38.8  0.5 \n#> 3 Adelie                40.8  0.75\n#> 4 Chinstrap             46.3  0.25\n#> 5 Chinstrap             49.6  0.5 \n#> 6 Chinstrap             51.1  0.75\n#> 7 Gentoo                45.3  0.25\n#> 8 Gentoo                47.3  0.5 \n#> 9 Gentoo                49.6  0.75\n```\n:::\n\n\n\n\nOr return multiple columns from a single summary expression:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_grouped %>%\n  summarize(tibble(\n    min = min(bill_depth_mm, na.rm = TRUE),\n    max = max(bill_depth_mm, na.rm = TRUE)\n  ))\n#> # A tibble: 3 × 3\n#>   species     min   max\n#>   <fct>     <dbl> <dbl>\n#> 1 Adelie     15.5  21.5\n#> 2 Chinstrap  16.4  20.8\n#> 3 Gentoo     13.1  17.3\n```\n:::\n\n\n\n\nAt the first glance this may seem not so different with supplying multiple name-value pairs. But this can be useful inside functions. For example, in the previous `quantile` code it would be nice to be able to reduce the duplication so that we don’t have to type the quantile values twice. We can now write a simple function because summary expressions can now be data frames or tibbles:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquibble <- function(x, q = c(0.25, 0.5, 0.75), na.rm = TRUE) {\n  tibble(x = quantile(x, q, na.rm = na.rm), q = q)\n}\n\npenguins_grouped %>%\n  summarize(quibble(bill_depth_mm))\n#> Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\n#> dplyr 1.1.0.\n#> ℹ Please use `reframe()` instead.\n#> ℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n#>   always returns an ungrouped data frame and adjust accordingly.\n#> `summarise()` has grouped output by 'species'. You can override using the\n#> `.groups` argument.\n#> # A tibble: 9 × 3\n#> # Groups:   species [3]\n#>   species       x     q\n#>   <fct>     <dbl> <dbl>\n#> 1 Adelie     17.5  0.25\n#> 2 Adelie     18.4  0.5 \n#> 3 Adelie     19    0.75\n#> 4 Chinstrap  17.5  0.25\n#> 5 Chinstrap  18.4  0.5 \n#> 6 Chinstrap  19.4  0.75\n#> 7 Gentoo     14.2  0.25\n#> 8 Gentoo     15    0.5 \n#> 9 Gentoo     15.7  0.75\n```\n:::\n\n\n\nWhen combining glue syntax and tidy evaluation, it is easy to dynamically name the column names.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquibble <- function(x, q = c(0.25, 0.5, 0.75), na.rm = TRUE) {\n  tibble(\n    \"{{ x }}_quantile\" := quantile(x, q, na.rm = na.rm),\n    \"{{ x }}_q\" := q\n  )\n}\n\npenguins_grouped %>%\n  summarize(quibble(flipper_length_mm))\n#> Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\n#> dplyr 1.1.0.\n#> ℹ Please use `reframe()` instead.\n#> ℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n#>   always returns an ungrouped data frame and adjust accordingly.\n#> `summarise()` has grouped output by 'species'. You can override using the\n#> `.groups` argument.\n#> # A tibble: 9 × 3\n#> # Groups:   species [3]\n#>   species   flipper_length_mm_quantile flipper_length_mm_q\n#>   <fct>                          <dbl>               <dbl>\n#> 1 Adelie                           186                0.25\n#> 2 Adelie                           190                0.5 \n#> 3 Adelie                           195                0.75\n#> 4 Chinstrap                        191                0.25\n#> 5 Chinstrap                        196                0.5 \n#> 6 Chinstrap                        201                0.75\n#> 7 Gentoo                           212                0.25\n#> 8 Gentoo                           216                0.5 \n#> 9 Gentoo                           221                0.75\n```\n:::\n\n\n\nAs an aside, if we name the tibble expression in `summarize()` that part will be packed in the result, which can be solved by `tidyr::unpack`. That’s because when we leave the name off, the data frame result is automatically unpacked.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_grouped %>%\n  summarize(df = quibble(flipper_length_mm))\n#> Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\n#> dplyr 1.1.0.\n#> ℹ Please use `reframe()` instead.\n#> ℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n#>   always returns an ungrouped data frame and adjust accordingly.\n#> `summarise()` has grouped output by 'species'. You can override using the\n#> `.groups` argument.\n#> # A tibble: 9 × 2\n#> # Groups:   species [3]\n#>   species   df$flipper_length_mm_quantile $flipper_length_mm_q\n#>   <fct>                             <dbl>                <dbl>\n#> 1 Adelie                              186                 0.25\n#> 2 Adelie                              190                 0.5 \n#> 3 Adelie                              195                 0.75\n#> 4 Chinstrap                           191                 0.25\n#> 5 Chinstrap                           196                 0.5 \n#> 6 Chinstrap                           201                 0.75\n#> 7 Gentoo                              212                 0.25\n#> 8 Gentoo                              216                 0.5 \n#> 9 Gentoo                              221                 0.75\n```\n:::\n\n\n\n\n\n### non-summary context\n\nIn combination with rowwise operations,  `summarize()` is now sufficiently powerful to replace many workflows that previously required a `map()` function.\n\nFor example, to read all the all the .csv files in the current directory, you could write:\n\n```r\ntibble(path = dir(pattern = \"\\\\.csv$\")) %>%\n  rowwise(path) %>%\n  summarize(read_csv(path))\n```\n\n\n## Move columns around within data frames\n\nNew verb `relocate` is provided to change column positions with the same syntax as `select`. The default behavior is to move selected columns to the left-hand side\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% relocate(island)\n#> # A tibble: 344 × 8\n#>    island    species bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n#>    <fct>     <fct>            <dbl>         <dbl>             <int>       <int>\n#>  1 Torgersen Adelie            39.1          18.7               181        3750\n#>  2 Torgersen Adelie            39.5          17.4               186        3800\n#>  3 Torgersen Adelie            40.3          18                 195        3250\n#>  4 Torgersen Adelie            NA            NA                  NA          NA\n#>  5 Torgersen Adelie            36.7          19.3               193        3450\n#>  6 Torgersen Adelie            39.3          20.6               190        3650\n#>  7 Torgersen Adelie            38.9          17.8               181        3625\n#>  8 Torgersen Adelie            39.2          19.6               195        4675\n#>  9 Torgersen Adelie            34.1          18.1               193        3475\n#> 10 Torgersen Adelie            42            20.2               190        4250\n#> # ℹ 334 more rows\n#> # ℹ 2 more variables: sex <fct>, year <int>\n\npenguins %>% relocate(starts_with(\"bill\"))\n#> # A tibble: 344 × 8\n#>    bill_length_mm bill_depth_mm species island    flipper_length_mm body_mass_g\n#>             <dbl>         <dbl> <fct>   <fct>                 <int>       <int>\n#>  1           39.1          18.7 Adelie  Torgersen               181        3750\n#>  2           39.5          17.4 Adelie  Torgersen               186        3800\n#>  3           40.3          18   Adelie  Torgersen               195        3250\n#>  4           NA            NA   Adelie  Torgersen                NA          NA\n#>  5           36.7          19.3 Adelie  Torgersen               193        3450\n#>  6           39.3          20.6 Adelie  Torgersen               190        3650\n#>  7           38.9          17.8 Adelie  Torgersen               181        3625\n#>  8           39.2          19.6 Adelie  Torgersen               195        4675\n#>  9           34.1          18.1 Adelie  Torgersen               193        3475\n#> 10           42            20.2 Adelie  Torgersen               190        4250\n#> # ℹ 334 more rows\n#> # ℹ 2 more variables: sex <fct>, year <int>\n\npenguins %>% relocate(sex, body_mass_g, .after = species)\n#> # A tibble: 344 × 8\n#>    species sex    body_mass_g island    bill_length_mm bill_depth_mm\n#>    <fct>   <fct>        <int> <fct>              <dbl>         <dbl>\n#>  1 Adelie  male          3750 Torgersen           39.1          18.7\n#>  2 Adelie  female        3800 Torgersen           39.5          17.4\n#>  3 Adelie  female        3250 Torgersen           40.3          18  \n#>  4 Adelie  <NA>            NA Torgersen           NA            NA  \n#>  5 Adelie  female        3450 Torgersen           36.7          19.3\n#>  6 Adelie  male          3650 Torgersen           39.3          20.6\n#>  7 Adelie  female        3625 Torgersen           38.9          17.8\n#>  8 Adelie  male          4675 Torgersen           39.2          19.6\n#>  9 Adelie  <NA>          3475 Torgersen           34.1          18.1\n#> 10 Adelie  <NA>          4250 Torgersen           42            20.2\n#> # ℹ 334 more rows\n#> # ℹ 2 more variables: flipper_length_mm <int>, year <int>\n```\n:::\n\n\n\n\nSimilarly, `mutate` gains new arguments `.after` and `.before` to control where new columns should appear.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>%\n  mutate(mass_double = body_mass_g * 2, .before = 1)\n#> # A tibble: 344 × 9\n#>    mass_double species island    bill_length_mm bill_depth_mm flipper_length_mm\n#>          <dbl> <fct>   <fct>              <dbl>         <dbl>             <int>\n#>  1        7500 Adelie  Torgersen           39.1          18.7               181\n#>  2        7600 Adelie  Torgersen           39.5          17.4               186\n#>  3        6500 Adelie  Torgersen           40.3          18                 195\n#>  4          NA Adelie  Torgersen           NA            NA                  NA\n#>  5        6900 Adelie  Torgersen           36.7          19.3               193\n#>  6        7300 Adelie  Torgersen           39.3          20.6               190\n#>  7        7250 Adelie  Torgersen           38.9          17.8               181\n#>  8        9350 Adelie  Torgersen           39.2          19.6               195\n#>  9        6950 Adelie  Torgersen           34.1          18.1               193\n#> 10        8500 Adelie  Torgersen           42            20.2               190\n#> # ℹ 334 more rows\n#> # ℹ 3 more variables: body_mass_g <int>, sex <fct>, year <int>\n```\n:::\n\n\n\n## Row mutation\n\ndplyr has a new experimental family of row mutation functions inspired by SQL’s `UPDATE`, `INSERT`, `UPSERT`, and `DELETE`. Like the join functions, they all work with a pair of data frames:\n\n\n- `rows_update(x, y)` updates existing rows in x with values in y.\n\n- `rows_patch(x, y)` works like rows_update() but only changes `NA` values.\n\n- `rows_insert(x, y)` adds new rows to x from y.\n\n- `rows_upsert(x, y)` updates existing rows in x and adds new rows from y.\n\n- `rows_delete(x, y)` deletes rows in x that match rows in y.\n\n\nThe `rows_` functions match x and y using **keys**.  All of them check that the keys of x and y are valid (i.e. unique) before doing anything.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(a = 1:3, b = letters[c(1:2, NA)], c = 0.5 + 0:2)\ndf\n#> # A tibble: 3 × 3\n#>       a b         c\n#>   <int> <chr> <dbl>\n#> 1     1 a       0.5\n#> 2     2 b       1.5\n#> 3     3 <NA>    2.5\n```\n:::\n\n\n\nWe can use `rows_insert()` to add new rows:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew <- tibble(a = c(4, 5), b = c(\"d\", \"e\"), c = c(3.5, 4.5))\n\nrows_insert(df, new)\n#> Matching, by = \"a\"\n#> # A tibble: 5 × 3\n#>       a b         c\n#>   <int> <chr> <dbl>\n#> 1     1 a       0.5\n#> 2     2 b       1.5\n#> 3     3 <NA>    2.5\n#> 4     4 d       3.5\n#> 5     5 e       4.5\n```\n:::\n\n\nNote that `rows_insert()` will fail if we attempt to insert a row that already exists:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% rows_insert(tibble(a = 3, b = \"c\"))\n#> Matching, by = \"a\"\n#> Error in `rows_insert()`:\n#> ! `y` can't contain keys that already exist in `x`.\n#> ℹ The following rows in `y` have keys that already exist in `x`: `c(1)`.\n#> ℹ Use `conflict = \"ignore\"` if you want to ignore these `y` rows.\n\ndf %>% rows_insert(tibble(a = 3, b = \"c\"), by = c(\"a\", \"b\"))\n#> # A tibble: 4 × 3\n#>       a b         c\n#>   <int> <chr> <dbl>\n#> 1     1 a       0.5\n#> 2     2 b       1.5\n#> 3     3 <NA>    2.5\n#> 4     3 c      NA\n```\n:::\n\n\n\nIf you want to update existing values, use `rows_update()`. It will throw an error if one of the rows to update does not exist:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% rows_update(tibble(a = 3, b = \"c\"))\n#> Matching, by = \"a\"\n#> # A tibble: 3 × 3\n#>       a b         c\n#>   <int> <chr> <dbl>\n#> 1     1 a       0.5\n#> 2     2 b       1.5\n#> 3     3 c       2.5\n\ndf %>% rows_update(tibble(a = 4, b = \"d\"))\n#> Matching, by = \"a\"\n#> Error in `rows_update()`:\n#> ! `y` must contain keys that already exist in `x`.\n#> ℹ The following rows in `y` have keys that don't exist in `x`: `c(1)`.\n#> ℹ Use `unmatched = \"ignore\"` if you want to ignore these `y` rows.\n```\n:::\n\n\n`rows_patch()` is a variant of `rows_update()` that will only update values in x that are `NA`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% rows_patch(tibble(a = 1:3, b = \"patch\"))\n#> Matching, by = \"a\"\n#> # A tibble: 3 × 3\n#>       a b         c\n#>   <int> <chr> <dbl>\n#> 1     1 a       0.5\n#> 2     2 b       1.5\n#> 3     3 patch   2.5\n```\n:::\n\n\n\n`row_upsert` update a df or insert new rows.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  rows_upsert(tibble(a = 3, b = \"c\")) %>% # update\n  rows_upsert(tibble(a = 4, b = \"d\")) # insert\n#> Matching, by = \"a\"\n#> Matching, by = \"a\"\n#> # A tibble: 4 × 3\n#>       a b         c\n#>   <int> <chr> <dbl>\n#> 1     1 a       0.5\n#> 2     2 b       1.5\n#> 3     3 c       2.5\n#> 4     4 d      NA\n```\n:::\n\n\n\n\n\n## Context dependent expressions\n\n`n()` is a special function in dplyr which return the number of observations in the current group. Now the new version comes with more such special functions, aka context dependent expressions. These functions return information about the \"current\" group or \"current\" variable, so only work inside specific contexts like `summarize()` and `mutate()`. Specifically, a family of `cur_` functions are added:\n\n- `cur_data()` gives the current data for the current group (exclusing grouping variables, `cur_data_all` in developmental version returns grouping variables as well)\n\n- `cur_group()` gives the group keys, a tibble with one row and one column for each grouping variable.\n\n- `cur_group_id()` gives a unique numeric identifier for the current group\n\n- `cur_column()` gives the **name** of the current column (in `across()` only).\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(\n  g = sample(rep(letters[1:3], 1:3)),\n  x = runif(6),\n  y = runif(6)\n)\ngf <- df %>% group_by(g)\n\ngf %>% summarize(row = cur_group_rows())\n#> Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\n#> dplyr 1.1.0.\n#> ℹ Please use `reframe()` instead.\n#> ℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n#>   always returns an ungrouped data frame and adjust accordingly.\n#> `summarise()` has grouped output by 'g'. You can override using the `.groups`\n#> argument.\n#> # A tibble: 6 × 2\n#> # Groups:   g [3]\n#>   g       row\n#>   <chr> <int>\n#> 1 a         2\n#> 2 b         1\n#> 3 b         3\n#> 4 c         4\n#> 5 c         5\n#> 6 c         6\ngf %>% summarize(data = list(cur_group()))\n#> # A tibble: 3 × 2\n#>   g     data            \n#>   <chr> <list>          \n#> 1 a     <tibble [1 × 1]>\n#> 2 b     <tibble [1 × 1]>\n#> 3 c     <tibble [1 × 1]>\ngf %>% summarize(data = list(cur_data()))\n#> Warning: There was 1 warning in `summarize()`.\n#> ℹ In argument: `data = list(cur_data())`.\n#> ℹ In group 1: `g = \"a\"`.\n#> Caused by warning:\n#> ! `cur_data()` was deprecated in dplyr 1.1.0.\n#> ℹ Please use `pick()` instead.\n#> # A tibble: 3 × 2\n#>   g     data            \n#>   <chr> <list>          \n#> 1 a     <tibble [1 × 2]>\n#> 2 b     <tibble [2 × 2]>\n#> 3 c     <tibble [3 × 2]>\n# has nothing to do with groups\ngf %>% mutate(across(everything(), ~ paste(cur_column(), round(.x, 2))))\n#> # A tibble: 6 × 3\n#> # Groups:   g [3]\n#>   g     x      y     \n#>   <chr> <chr>  <chr> \n#> 1 b     x 0.2  y 0.75\n#> 2 a     x 0.74 y 0.63\n#> 3 b     x 0.21 y 0.12\n#> 4 c     x 0.62 y 0.12\n#> 5 c     x 0.39 y 0.63\n#> 6 c     x 0.79 y 0.85\n```\n:::\n\n\n\n\n\n\n\n## Superseded functions\n\n`top_n()`, `sample_n()`, and `sample_frac()` have been superseded in favor of a new family of slice helpers: `slice_min()`, `slice_max()`, `slice_head()`, `slice_tail()`, `slice_random()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# select penguins per group on body mass\npenguins_grouped %>%\n  slice_max(body_mass_g, n = 1)\n#> # A tibble: 3 × 8\n#> # Groups:   species [3]\n#>   species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n#>   <fct>     <fct>           <dbl>         <dbl>             <int>       <int>\n#> 1 Adelie    Biscoe           43.2          19                 197        4775\n#> 2 Chinstrap Dream            52            20.7               210        4800\n#> 3 Gentoo    Biscoe           49.2          15.2               221        6300\n#> # ℹ 2 more variables: sex <fct>, year <int>\n\npenguins_grouped %>%\n  slice_min(body_mass_g, n = 1)\n#> # A tibble: 4 × 8\n#> # Groups:   species [3]\n#>   species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n#>   <fct>     <fct>           <dbl>         <dbl>             <int>       <int>\n#> 1 Adelie    Biscoe           36.5          16.6               181        2850\n#> 2 Adelie    Biscoe           36.4          17.1               184        2850\n#> 3 Chinstrap Dream            46.9          16.6               192        2700\n#> 4 Gentoo    Biscoe           42.7          13.7               208        3950\n#> # ℹ 2 more variables: sex <fct>, year <int>\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# random sampling\npenguins %>%\n  slice_sample(n = 10)\n#> # A tibble: 10 × 8\n#>    species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n#>    <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n#>  1 Adelie  Biscoe              41            20                 203        4725\n#>  2 Adelie  Torgersen           39.6          17.2               196        3550\n#>  3 Adelie  Torgersen           34.6          21.1               198        4400\n#>  4 Gentoo  Biscoe              43.2          14.5               208        4450\n#>  5 Adelie  Biscoe              38.2          18.1               185        3950\n#>  6 Gentoo  Biscoe              44            13.6               208        4350\n#>  7 Gentoo  Biscoe              43.3          14                 208        4575\n#>  8 Adelie  Dream               36            18.5               186        3100\n#>  9 Gentoo  Biscoe              53.4          15.8               219        5500\n#> 10 Adelie  Torgersen           34.6          17.2               189        3200\n#> # ℹ 2 more variables: sex <fct>, year <int>\n\npenguins %>%\n  slice_sample(prop = 0.1)\n#> # A tibble: 34 × 8\n#>    species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n#>    <fct>     <fct>           <dbl>         <dbl>             <int>       <int>\n#>  1 Adelie    Biscoe           35.7          16.9               185        3150\n#>  2 Gentoo    Biscoe           45.2          13.8               215        4750\n#>  3 Gentoo    Biscoe           46.1          13.2               211        4500\n#>  4 Adelie    Dream            40.6          17.2               187        3475\n#>  5 Gentoo    Biscoe           45.2          16.4               223        5950\n#>  6 Gentoo    Biscoe           45.5          15                 220        5000\n#>  7 Gentoo    Biscoe           46.8          16.1               215        5500\n#>  8 Chinstrap Dream            45.7          17                 195        3650\n#>  9 Gentoo    Biscoe           45            15.4               220        5050\n#> 10 Chinstrap Dream            52            18.1               201        4050\n#> # ℹ 24 more rows\n#> # ℹ 2 more variables: sex <fct>, year <int>\n```\n:::\n\n\n\n`summarize()` gains new argument `.groups` to control grouping structure of theh result.\n\n\n- `.groups = \"drop_last\"` drops the last grouping level (i.e. the default behaviour).\n\n- `.groups = \"drop\"` drops all grouping levels and returns a tibble.\n\n- `.groups = \"keep\"` preserves the grouping of the input.\n\n- `.groups = \"rowwise\"` turns each row into its own group.\n\n\n## Other changes\n\nThe new `rename_with()` makes it easier to rename variables programmatically:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>%\n  rename_with(stringr::str_to_upper)\n#> # A tibble: 344 × 8\n#>    SPECIES ISLAND    BILL_LENGTH_MM BILL_DEPTH_MM FLIPPER_LENGTH_MM BODY_MASS_G\n#>    <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n#>  1 Adelie  Torgersen           39.1          18.7               181        3750\n#>  2 Adelie  Torgersen           39.5          17.4               186        3800\n#>  3 Adelie  Torgersen           40.3          18                 195        3250\n#>  4 Adelie  Torgersen           NA            NA                  NA          NA\n#>  5 Adelie  Torgersen           36.7          19.3               193        3450\n#>  6 Adelie  Torgersen           39.3          20.6               190        3650\n#>  7 Adelie  Torgersen           38.9          17.8               181        3625\n#>  8 Adelie  Torgersen           39.2          19.6               195        4675\n#>  9 Adelie  Torgersen           34.1          18.1               193        3475\n#> 10 Adelie  Torgersen           42            20.2               190        4250\n#> # ℹ 334 more rows\n#> # ℹ 2 more variables: SEX <fct>, YEAR <int>\n```\n:::\n\n\nYou can optionally choose which columns to apply the transformation to with the second argument:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>%\n  rename_with(stringr::str_to_upper, starts_with(\"bill\"))\n#> # A tibble: 344 × 8\n#>    species island    BILL_LENGTH_MM BILL_DEPTH_MM flipper_length_mm body_mass_g\n#>    <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n#>  1 Adelie  Torgersen           39.1          18.7               181        3750\n#>  2 Adelie  Torgersen           39.5          17.4               186        3800\n#>  3 Adelie  Torgersen           40.3          18                 195        3250\n#>  4 Adelie  Torgersen           NA            NA                  NA          NA\n#>  5 Adelie  Torgersen           36.7          19.3               193        3450\n#>  6 Adelie  Torgersen           39.3          20.6               190        3650\n#>  7 Adelie  Torgersen           38.9          17.8               181        3625\n#>  8 Adelie  Torgersen           39.2          19.6               195        4675\n#>  9 Adelie  Torgersen           34.1          18.1               193        3475\n#> 10 Adelie  Torgersen           42            20.2               190        4250\n#> # ℹ 334 more rows\n#> # ℹ 2 more variables: sex <fct>, year <int>\n```\n:::\n\n\n\n`mutate()` gains argument `.keep` that allows you to control which columns are retained in the output:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% mutate(\n  double_mass = body_mass_g * 2,\n  island_lower = stringr::str_to_lower(island),\n  .keep = \"used\"\n)\n#> # A tibble: 344 × 4\n#>    island    body_mass_g double_mass island_lower\n#>    <fct>           <int>       <dbl> <chr>       \n#>  1 Torgersen        3750        7500 torgersen   \n#>  2 Torgersen        3800        7600 torgersen   \n#>  3 Torgersen        3250        6500 torgersen   \n#>  4 Torgersen          NA          NA torgersen   \n#>  5 Torgersen        3450        6900 torgersen   \n#>  6 Torgersen        3650        7300 torgersen   \n#>  7 Torgersen        3625        7250 torgersen   \n#>  8 Torgersen        4675        9350 torgersen   \n#>  9 Torgersen        3475        6950 torgersen   \n#> 10 Torgersen        4250        8500 torgersen   \n#> # ℹ 334 more rows\n\npenguins %>% mutate(double_mass = body_mass_g * 2, .keep = \"none\")\n#> # A tibble: 344 × 1\n#>    double_mass\n#>          <dbl>\n#>  1        7500\n#>  2        7600\n#>  3        6500\n#>  4          NA\n#>  5        6900\n#>  6        7300\n#>  7        7250\n#>  8        9350\n#>  9        6950\n#> 10        8500\n#> # ℹ 334 more rows\n```\n:::\n\n\n\n\n\n\n## Use cases\n\nThis in-progress section documents tasks that would otherwise been impossible or laborious with previous version of dplyr.\n\n### Replace missing values in many columns\n\nSince `tidyr::replace_na` does not support tidy select syntax, replacing NA values in multiple columns could be a drudgery. Now this is made easy with `coalesce` and `across`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins %>% summarize(across(starts_with(\"bill\"), ~ sum(is.na(.x))))\n#> # A tibble: 1 × 2\n#>   bill_length_mm bill_depth_mm\n#>            <int>         <int>\n#> 1              2             2\n\npenguins %>%\n  mutate(across(starts_with(\"bill\"), ~ coalesce(.x, 0))) %>%\n  summarize(across(starts_with(\"bill\"), ~ sum(is.na(.x))))\n#> # A tibble: 1 × 2\n#>   bill_length_mm bill_depth_mm\n#>            <int>         <int>\n#> 1              0             0\n```\n:::\n\n\n\n### Rolling regression\n\n`cur_data()` is particularly useful for rolling regression, in conjunction with the [slider](https://davisvaughan.github.io/slider/) package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(slider)\nlibrary(lubridate)\n#> \n#> Attaching package: 'lubridate'\n#> The following objects are masked from 'package:base':\n#> \n#>     date, intersect, setdiff, union\n# historical stock prices from 2014-2018 for Google, Amazon, Facebook and Apple\nstock <- tsibbledata::gafa_stock %>% select(Symbol, Date, Close, Volume)\nstock\n#> # A tibble: 5,032 × 4\n#>    Symbol Date       Close    Volume\n#>    <chr>  <date>     <dbl>     <dbl>\n#>  1 AAPL   2014-01-02  79.0  58671200\n#>  2 AAPL   2014-01-03  77.3  98116900\n#>  3 AAPL   2014-01-06  77.7 103152700\n#>  4 AAPL   2014-01-07  77.1  79302300\n#>  5 AAPL   2014-01-08  77.6  64632400\n#>  6 AAPL   2014-01-09  76.6  69787200\n#>  7 AAPL   2014-01-10  76.1  76244000\n#>  8 AAPL   2014-01-13  76.5  94623200\n#>  9 AAPL   2014-01-14  78.1  83140400\n#> 10 AAPL   2014-01-15  79.6  97909700\n#> # ℹ 5,022 more rows\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Arrange and group by `Symbol` (i.e. Google)\nstock <- stock %>%\n  arrange(Symbol, Date) %>%\n  group_by(Symbol)\n\nlinear_model <- function(df) {\n  lm(Close ~ Volume, data = df)\n}\n\n# 10 day rolling regression per group\nstock %>%\n  mutate(model = slide_index(\n    cur_data(),\n    Date,\n    linear_model,\n    .before = days(9),\n    .complete = TRUE\n  ))\n#> # A tibble: 5,032 × 5\n#> # Groups:   Symbol [4]\n#>    Symbol Date       Close    Volume model \n#>    <chr>  <date>     <dbl>     <dbl> <list>\n#>  1 AAPL   2014-01-02  79.0  58671200 <NULL>\n#>  2 AAPL   2014-01-03  77.3  98116900 <NULL>\n#>  3 AAPL   2014-01-06  77.7 103152700 <NULL>\n#>  4 AAPL   2014-01-07  77.1  79302300 <NULL>\n#>  5 AAPL   2014-01-08  77.6  64632400 <NULL>\n#>  6 AAPL   2014-01-09  76.6  69787200 <NULL>\n#>  7 AAPL   2014-01-10  76.1  76244000 <NULL>\n#>  8 AAPL   2014-01-13  76.5  94623200 <lm>  \n#>  9 AAPL   2014-01-14  78.1  83140400 <lm>  \n#> 10 AAPL   2014-01-15  79.6  97909700 <lm>  \n#> # ℹ 5,022 more rows\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}