{
  "hash": "6330b40f32f4deba9f1747eb0d149e3b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Structural pattern matching in Python 3.10\nslug: python310-pattern-matching\ndate: '2022-02-20'\ndescription: |\n    The  _py`match case`_  statement for pattern matching is an exciting new feature added in Python 3.10. This article reviews the syntax and shows some practical examples.\n---\n\n\n\n\n\n## Introduction\n\n[Structural Pattern Matching](https://www.python.org/dev/peps/pep-0634/) is a new feature introduced in python [3.10](https://docs.python.org/3/whatsnew/3.10.html), and perhaps the most intriguing one. It takes as input an object to inspect (following _py`match`_), and multiple patterns to match against (following one or more _py`case`_). If there is a match, a pattern-specific code block runs. The basic syntax is\n\n<!-- ```{r, include = FALSE}\nymisc::set_knitr_options()\nlibrary(reticulate)\nSys.setenv(RETICULATE_PYTHON = \"/opt/homebrew/Cellar/python@3.10/3.10.5/bin/python3\")\n``` -->\n\n\n::: {.cell}\n\n```{.python .cell-code}\nerror_code = 403\nmatch error_code:\n    case 400:\n        print(\"Bad request\")\n    case 403:\n        print(\"Unauthorized\")\n    case 500:\n        print(\"Internal server error\")\n# !callout[/case _/] the default case when none of the above matches :right\n    case _:\n        print(\"Something's wrong with the Internet\")\n#> Unauthorized\n```\n:::\n\nHere, we check case by case if `error_code` is equal to a value, if it's not one of 400, 403, 500, `_` will be a catch-all wildcard. Also, pattern matching will break when it hits a match, so each `case` should be independent.\n\n\n\nTo run examples in this article, be sure you are using python higher than 3.10. To check, use\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport sys\nsys.version\n#> '3.10.14 (main, Mar 19 2024, 21:46:16) [Clang 15.0.0 (clang-1500.3.9.4)]'\n```\n:::\n\n\n\n\n## Pattern matching as a replacement for switch statements\n\nThe most apparent usage of pattern matching is implementing `switch ... case` statements in many other programming languages, which is a replacement for multiple if else statements. Imagine we are building a game, and we have a `move` function for controlling figure movement.\n\n```python\ndef move(self, direction):\n    match direction:\n        case \"up\":\n            self.move_up()\n        case \"down\":\n            self.move_down()\n        case \"left\":\n            self.move_left()\n        case \"right\":\n            self.move_right()\n```\n\n## Match dictionaries and lists\n\nThe real power of pattern matching resides in destructuring data structures like lists and dictionaries.\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmatch {\"first_name\": \"Jane\", \"last_name\": \"Doe\", \"middle_name\": \"\"}:\n    case {\"first_name\": first_name , \"last_name\": last_name}:\n        print(first_name, last_name)\n#> Jane Doe\n```\n:::\n\n\n\nIn the example above, we supplied a pattern that says the object should contains keys \"first_name\" and \"last_name\", if the pattern matches, their values will be captured into the variables `first_name` and `last_name`. Note that for an dictionary, structural pattern matching matches the structure instead of the exact content, the pattern is valid as long as \"first_name\" and \"last_name\" are one of the object's keys, any unmentioned keys, like \"middle_name\", will be ignored.\n\nFor a more advanced example, suppose we are working with the [SpaceX API](https://docs.spacexdata.com/) to retrieve launch data, an individual record of launch looks like\n\n```json\n{\n        \"flight_number\": 1,\n        \"mission_name\": \"FalconSat\",\n        \"upcoming\": false,\n        \"launch_year\": \"2006\",\n        \"launch_date_unix\": 1143239400,\n        \"rocket\": {\n            \"rocket_id\": \"falcon1\",\n            \"rocket_name\": \"Falcon 1\",\n        },\n        \"details\": \"Engine failure at 33 seconds and loss of vehicle\",\n        //... other fields\n}\n```\n\nWe only want to get the fields `mission_name`, `rocket_name` and `details`. Note that\n\n\n\n\n::: {.cell output-lang='json'}\n\n```{.python .cell-code}\nimport requests\nimport json\nfrom pprint import pp\nres = requests.get(\"https://api.spacexdata.com/v3/launches?limit=3\")\ndata = res.json()\nout = []\nfor launch in data:\n    match launch:\n        case {\"mission_name\": mname, \"rocket\": {\"rocket_name\": rname}, \"details\": details}:\n            out.append({\"mission_name\": mname, \"rocket_name\": rname, \"details\": details})\n\npp(out)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [{'mission_name': 'FalconSat',\n#>   'rocket_name': 'Falcon 1',\n#>   'details': 'Engine failure at 33 seconds and loss of vehicle'},\n#>  {'mission_name': 'DemoSat',\n#>   'rocket_name': 'Falcon 1',\n#>   'details': 'Successful first stage burn and transition to second stage, '\n#>              'maximum altitude 289 km, Premature engine shutdown at T+7 min 30 '\n#>              's, Failed to reach orbit, Failed to recover first stage'},\n#>  {'mission_name': 'Trailblazer',\n#>   'rocket_name': 'Falcon 1',\n#>   'details': 'Residual stage 1 thrust led to collision between stage 1 and '\n#>              'stage 2'}]\n```\n\n\n:::\n:::\n\n\n\nHere, not only are we matching top level key `mission_name` and `details`, we also use a nested pattern to extract rocket name.\n\nYou can also match on a list.\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmatch [1, 2, 3]:\n    case [1, 2]:\n        print(\"match 1\")\n# !callout[/\\*rest/] match the the rest of elements\n    case [2, *rest]:\n        print(\"match 2\")\n        print(rest)\n# !callout[/\\*other/] match elements except the last one\n    case[*other, last]:\n        print(\"match 3\")\n        print(last)\n        print(other)\n#> match 3\n#> 3\n#> [1, 2]\n```\n:::\n\n\n\nI mentioned that pattern matching for dict does not require use to explicitly declare all fields. For lists this is different, we have to declare all elements, this is why match 1 fails. Match 2 attempts to use the `*` syntax to capture all values after 2 into a list called `rest`. This is helpful in case the list is really large and it's impossible to exhaust all elements, or we simply don't care about some elements. However, the second pattern does not specify the correct order, as 2 is not the first element in the matching object. Match 3 captures all elements but the last into `other`, and assign the last element to `last`.\n\n\nIt's also possible to express `or` logic with `|` in case statement. For example, we may add a `case 401 | 403 | 404: \"Not allowed\"` statement to our first example. Here is another example from pep:\n\n```python\nmatch command.split():\n    ... # Other cases\n    case [\"north\"] | [\"go\", \"north\"]:\n        current_room = current_room.neighbor(\"north\")\n    case [\"get\", obj] | [\"pick\", \"up\", obj] | [\"pick\", obj, \"up\"]:\n        ... # Code for picking up the given object\n```\n\nLiteral patterns can also be captured using the `as` keyword\n\n```python\nmatch command.split():\n    case [\"go\", (\"north\" | \"south\" | \"east\" | \"west\") as direction]:\n        current_room = current_room.neighbor(direction)\n```\n\n## Add conditions\n\nPattern matching allows if conditions the same way as list comprehension, we can append an _py`if ... else`_ clause like so\n\n\n```python\nall_directions = [\"up\", \"down\"]\n\nmatch commad.split():\n    case [\"go\", direction] if direction in all_directions:\n        move(direction)\n    case [\"go\", _]:\n        print(\"direction not supported\")\n```\n\n\nFor conditions that checks if an object is of a data type, we can directly use the class creator function:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef sum_list(numbers):\n    match numbers:\n        case []:\n            return 0\n        case [int(first) | float(first), *rest]:\n            return first + sum_list(rest)\n        case _:\n            raise ValueError(f\"Can only sum lists of numbers\")\n\nsum_list([1, 2, 3])\n#> 6\nsum_list([1, \"2\", 3])\n#> Can only sum lists of numbers\n```\n:::\n\n\n\nHere _py`int(first) | float(first)`_ checks if the first element is an integer or float. The next example uses a `dataclass` based pattern as well as its attributes\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom dataclasses import dataclass\n\n@dataclass\nclass Point:\n    x: float\n    y: float\n\np = Point(x = 1, y = 1)\n# data class for validation\nmatch p:\n    case Point(x = x):\n        print(x)\n#> 1\n```\n:::\n\n\n\n\nIn general, any class can be used for validation. This is also called a **class pattern**.\n\n## Matching constants\n\nCare should be taken when matching constants, since it's common to store the constant in an variable and then use it in `case`. The following code will not work:\n\n```python\ndirection = \"up\"\n\nmatch \"down\":\n# !callout[/direction/] capture \"up\" into the variable `direction` :right\n    case direction:\n        print(\"match\")\n    case _:\n        print(\"no match\")\n```\n\nWe are trying to match the value \"up\", but python interprets it as a capture pattern that says store whatever the match object is into the variable `direction`, so we are effectively overriding `direction` (recall the list matching example) and the first case always matches. Python will not allow this with an error message `SyntaxError: name capture 'direction' makes remaining patterns unreachable`.\n\nAs an alternative to matching literal values, we can use an enum type for constant matching instead\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport enum\nclass Direction(str, enum.Enum):\n    up = \"up\"\n    down = \"down\"\n\nmatch \"down\":\n    case Direction.up:\n        print(\"match 1\")\n    case Direction.down:\n        print(\"match 2\")\n    case _:\n        print(\"match 3\")\n#> match 2\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}